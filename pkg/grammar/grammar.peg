package grammar

type Parser Peg {
    InputAttributes
}

Valid
  <- Response / Command

Response
  <- Object? _ EOL Error? END

Command
  <- _ (Mutation / Query / StateBound) Flag* END

Mutation
  <- Item (CREATE / SET) Identifier ItemParams?
  / Item CLEAR Identifier ItemKeys
  / Item DELETE Identifier
  / Rel (CREATE / SET) DualIdentifier RelParams?
  / Rel CLEAR DualIdentifier RelKeys
  / Rel DELETE DualIdentifier
  / NEST Identifier+ IN Identifier
  / FREE Identifier+

Query
  <- FetchQuery / ExistsQuery

FetchQuery
  <- Item FETCH Identifier
  / ItemsList
  / Rel FETCH DualIdentifier
  / Rel Identifier !Identifier
  / RelsList
  / IN_QUERY Identifier
  / Item IN Identifier
  / WORLD

ExistsQuery
  <- ItemExists Identifier
  / RelExists DualIdentifier

StateBound
  <- CreateOrFetch / CreateOrSet

CreateOrFetch
  <- Item Identifier !ItemParams / Rel DualIdentifier !RelParams

CreateOrSet
  <- Item Identifier ItemParams / Rel DualIdentifier RelParams

Object
  <- WorldObject / ItemObject / RelObject / IdsList

WorldObject
  # This is laziness - I'm planning to just use JSON here...
  <- WORLD .* _

ItemObject
  <- Item Identifier ItemParams?

RelObject
  <- Rel DualIdentifier RelParams?

IdsList
  <- IDS (StringLike)* _

DualIdentifier
  <- Identifier Identifier

Identifier
  <- !(Keyword) StringLike

ItemParams
  <- (ItemParam)+

RelParams
  <- (RelParam)+

ItemParam
  <- EXTERNAL EQUALS Boolean
  / TYPE EQUALS ItemType
  / NAME EQUALS StringLike
  / MECHANISM EQUALS StringLike
  / EXPANDED EQUALS StringLike

RelParam
  <- VERB EQUALS StringLike
  / MECHANISM EQUALS StringLike
  / ASYNC EQUALS Boolean
  / EXPANDED EQUALS StringLike

ItemKeys
    <- (ItemKey)+

RelKeys
    <- (RelKey)+

ItemKey
    <- (NAME / TYPE / EXTERNAL / MECHANISM / EXPANDED) _

RelKey
    <- (VERB / MECHANISM / ASYNC / EXPANDED) _

Error
  <- ERROR StringLike*

StringLike
  <- (Text / QuotedText) _

Boolean
  <- TRUE / FALSE

Text
  <- [a-zA-Z0-9-_]+

QuotedText
 <- QUOTE [a-zA-Z0-9-_.,!@#$%^&*()\[\]+=~;: ]* QUOTE

ItemsList
    <- Item LIST Number?

RelsList
    <- Rel LIST Number?

Number
  <- [0-9]+ _

ItemType
  <- PERSON / DATABASE / QUEUE / BLOBSTORE / BROWSER / MOBILE / SERVER / DEVICE / CODE

ItemExists
  <- ITEM_EXISTS / Item EXISTS

RelExists
  <- REL_EXISTS / Rel EXISTS

Item
  <- ITEM

Rel
  <- REL

Flag <- StrictFlag / VerboseFlag / IdsFlag

StrictFlag
  <- FLAG STRICT

VerboseFlag
  <- FLAG VERBOSE

IdsFlag
  <- FLAG IDS

Keyword
  <- ITEM / ITEM_EXISTS / REL / REL_EXISTS / FROM_QUERY / TO_QUERY / IN / IN_QUERY / CREATE / DELETE / SET / CLEAR / FETCH / EXISTS / FREE / NEST / FLAG

WORLD       <- 'world' _
ITEM        <- 'item' 's'? _
ITEM_EXISTS <- 'item?' _
REL         <- 'rel' 's'? _
REL_EXISTS  <- 'rel?' _
FROM_QUERY  <- 'from?' _    # Rels from this Item to anywhere.
TO_QUERY    <- 'to?' _      # Rels from anywhere to this Item.
IN          <- 'in' _
IN_QUERY    <- 'in?' _      # Items under this one in the Tree, recursively unless STRICT set.
CREATE      <- 'create' _
DELETE      <- 'delete' _
SET         <- 'set' _
CLEAR       <- 'clear' _
FETCH       <- 'fetch' _
LIST        <- 'list' _
EXISTS      <- 'exists' _
FREE        <- 'free' _
NEST        <- 'nest' _
TRUE        <- 'true' _
FALSE       <- 'false' _

EXTERNAL    <- 'external'
NAME        <- 'name'
TYPE        <- 'type'
VERB        <- 'verb'
MECHANISM   <- 'mechanism'
ASYNC       <- 'async'
EXPANDED    <- 'expanded'

PERSON      <- 'person' _
DATABASE    <- 'database' _
QUEUE       <- 'queue' _
BLOBSTORE   <- 'blobstore' _
BROWSER     <- 'browser' _
MOBILE      <- 'mobile' _
SERVER      <- 'server' _
DEVICE      <- 'device' _
CODE        <- 'code' _

QUOTE       <- '"'
EQUALS      <- '='

FLAG       <- '-' / '--'
STRICT     <- 'strict' _
VERBOSE    <- 'verbose' _
IDS        <- 'ids' _

ERROR       <- 'error' _

_
  <- Whitespace*

Whitespace
  <- ' ' / '\t' / EOL

EOL
  <- '\r\n' / '\n' / '\r'

END
  <- !.