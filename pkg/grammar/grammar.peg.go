package grammar

// Code generated by peg -inline -switch -strict -output pkg/grammar/grammar.peg.go pkg/grammar/grammar.peg DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleValid
	ruleResponse
	ruleCommand
	ruleMutation
	ruleTreeMutation
	ruleQuery
	ruleFetchQuery
	ruleListQuery
	ruleExistsQuery
	ruleStateBound
	ruleCreateOrFetch
	ruleCreateOrSet
	ruleObjects
	ruleWorldObject
	ruleItemObject
	ruleRelObject
	ruleIdentifierListObject
	ruleTree
	ruleNil
	ruleErrorOrOkay
	ruleErrCode
	ruleLimit
	ruleIdentifier
	ruleSecondIdentifier
	ruleDualIdentifier
	ruleIdentifierList
	ruleItemParams
	ruleRelParams
	ruleItemParam
	ruleRelParam
	ruleItemKeys
	ruleRelKeys
	ruleItemKey
	ruleRelKey
	ruleStringLike
	ruleNumber
	ruleBoolean
	ruleText
	ruleQuotedText
	ruleItemExists
	ruleRelExists
	ruleWorld
	ruleItem
	ruleRel
	ruleCreate
	ruleFetch
	ruleSet
	ruleClear
	ruleDelete
	ruleList
	ruleNest
	ruleFree
	ruleExists
	ruleInQuery
	ruleFromQuery
	ruleToQuery
	ruleFlag
	ruleStrictFlag
	ruleVerboseFlag
	ruleIdsFlag
	ruleBeginWorld
	ruleEndWorld
	ruleItemType
	ruleKeyword
	ruleWORLD
	ruleENDWORLD
	ruleERROR
	ruleOK
	ruleITEM
	ruleITEM_EXISTS
	ruleREL
	ruleREL_EXISTS
	ruleFROM_QUERY
	ruleTO_QUERY
	ruleIN
	ruleIN_QUERY
	ruleCREATE
	ruleDELETE
	ruleSET
	ruleCLEAR
	ruleFETCH
	ruleLIST
	ruleEXISTS
	ruleFREE
	ruleNEST
	ruleTRUE
	ruleFALSE
	ruleEXTERNAL
	ruleNAME
	ruleTYPE
	ruleVERB
	ruleMECHANISM
	ruleASYNC
	ruleEXPANDED
	rulePERSON
	ruleDATABASE
	ruleQUEUE
	ruleBLOBSTORE
	ruleBROWSER
	ruleMOBILE
	ruleSERVER
	ruleDEVICE
	ruleCODE
	ruleDELIMITER
	ruleQUOTE
	ruleEQUALS
	ruleFLAG
	ruleSTRICT
	ruleVERBOSE
	ruleIDS
	rule_
	ruleWhitespace
	ruleEOL
	ruleEND
	ruleAction0
	ruleAction1
	rulePegText
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
)

var rul3s = [...]string{
	"Unknown",
	"Valid",
	"Response",
	"Command",
	"Mutation",
	"TreeMutation",
	"Query",
	"FetchQuery",
	"ListQuery",
	"ExistsQuery",
	"StateBound",
	"CreateOrFetch",
	"CreateOrSet",
	"Objects",
	"WorldObject",
	"ItemObject",
	"RelObject",
	"IdentifierListObject",
	"Tree",
	"Nil",
	"ErrorOrOkay",
	"ErrCode",
	"Limit",
	"Identifier",
	"SecondIdentifier",
	"DualIdentifier",
	"IdentifierList",
	"ItemParams",
	"RelParams",
	"ItemParam",
	"RelParam",
	"ItemKeys",
	"RelKeys",
	"ItemKey",
	"RelKey",
	"StringLike",
	"Number",
	"Boolean",
	"Text",
	"QuotedText",
	"ItemExists",
	"RelExists",
	"World",
	"Item",
	"Rel",
	"Create",
	"Fetch",
	"Set",
	"Clear",
	"Delete",
	"List",
	"Nest",
	"Free",
	"Exists",
	"InQuery",
	"FromQuery",
	"ToQuery",
	"Flag",
	"StrictFlag",
	"VerboseFlag",
	"IdsFlag",
	"BeginWorld",
	"EndWorld",
	"ItemType",
	"Keyword",
	"WORLD",
	"ENDWORLD",
	"ERROR",
	"OK",
	"ITEM",
	"ITEM_EXISTS",
	"REL",
	"REL_EXISTS",
	"FROM_QUERY",
	"TO_QUERY",
	"IN",
	"IN_QUERY",
	"CREATE",
	"DELETE",
	"SET",
	"CLEAR",
	"FETCH",
	"LIST",
	"EXISTS",
	"FREE",
	"NEST",
	"TRUE",
	"FALSE",
	"EXTERNAL",
	"NAME",
	"TYPE",
	"VERB",
	"MECHANISM",
	"ASYNC",
	"EXPANDED",
	"PERSON",
	"DATABASE",
	"QUEUE",
	"BLOBSTORE",
	"BROWSER",
	"MOBILE",
	"SERVER",
	"DEVICE",
	"CODE",
	"DELIMITER",
	"QUOTE",
	"EQUALS",
	"FLAG",
	"STRICT",
	"VERBOSE",
	"IDS",
	"_",
	"Whitespace",
	"EOL",
	"END",
	"Action0",
	"Action1",
	"PegText",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	StmtType string
	InputAttributes
	Response

	text   string // Text parsed by the StringLike rule.
	number int    // Number parsed by the Number rule.
	bool   bool   // Boolean parsed by the Boolean rule.

	treeString  string   // Track the string representation of the Tree parsed by the Tree rule.
	itemStrings []string // Track the string representations of Items parsed by the ItemObject rule.
	relStrings  []string // Track the string representations of Rels parsed by the RelObject rule.

	Buffer string
	buffer []rune
	rules  [168]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *Parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.StmtType = "Response"

		case ruleAction1:

			p.StmtType = "Command"
			p.InputAttributes.Raw = p.Buffer

		case ruleAction2:
			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		case ruleAction3:
			p.InputAttributes.Verb = "fetch"
		case ruleAction4:
			p.InputAttributes.Verb = "list"
		case ruleAction5:
			p.InputAttributes.Verb = "create-or-fetch"
		case ruleAction6:
			p.InputAttributes.Verb = "create-or-set"
		case ruleAction7:
			p.Response.Object.Type = "world"
			p.Response.Object.Repr = strings.Join(append([]string{p.treeString}, p.relStrings...), "\n")
		case ruleAction8:
			p.Response.Object.Type = "item"
			p.Response.Object.Repr = cleanString(text)
			p.itemStrings = append(p.itemStrings, strings.TrimSpace(text))
		case ruleAction9:
			p.Response.Object.Type = "rel"
			p.Response.Object.Repr = cleanString(text)
			p.relStrings = append(p.relStrings, strings.TrimSpace(text))
		case ruleAction10:
			p.Response.Object.Type = "ids"
			b, _ := json.Marshal(p.InputAttributes.ResourceIds)
			p.Response.Object.Repr = string(b)
		case ruleAction11:

			p.Response.Object.Type = "tree"
			p.Response.Object.Repr = text
			p.treeString = text

		case ruleAction12:

			p.Response.Status.Message = cleanString(text)

		case ruleAction13:
			p.Response.Status.Code = p.number
		case ruleAction14:
			p.InputAttributes.Params["limit"] = cleanString(text)
		case ruleAction15:
			p.InputAttributes.ResourceId = cleanString(text)
		case ruleAction16:

			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))

		case ruleAction17:

			p.InputAttributes.ResourceId = ""
			ids := strings.Fields(text)
			for _, id := range ids {
				p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
			}

		case ruleAction18:
			p.Params["external"] = cleanString(text)
		case ruleAction19:
			p.Params["type"] = cleanString(text)
		case ruleAction20:
			p.Params["name"] = cleanString(text)
		case ruleAction21:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction22:
			p.Params["expanded"] = cleanString(text)
		case ruleAction23:
			p.Params["verb"] = cleanString(text)
		case ruleAction24:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction25:
			p.Params["async"] = cleanString(text)
		case ruleAction26:
			p.Params["expanded"] = cleanString(text)
		case ruleAction27:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction28:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction29:
			p.text = cleanString(text)
		case ruleAction30:
			n, _ := strconv.Atoi(text)
			p.number = n
		case ruleAction31:
			p.bool = text == "true"
		case ruleAction32:
			p.InputAttributes.ResourceType = "item"
			p.InputAttributes.Verb = "exists"
		case ruleAction33:
			p.InputAttributes.ResourceType = "rel"
			p.InputAttributes.Verb = "exists"
		case ruleAction34:
			p.InputAttributes.ResourceType = "world"
		case ruleAction35:
			p.InputAttributes.ResourceType = "item"
		case ruleAction36:
			p.InputAttributes.ResourceType = "rel"
		case ruleAction37:
			p.InputAttributes.Verb = "create"
		case ruleAction38:
			p.InputAttributes.Verb = "fetch"
		case ruleAction39:
			p.InputAttributes.Verb = "set"
		case ruleAction40:
			p.InputAttributes.Verb = "clear"
		case ruleAction41:
			p.InputAttributes.Verb = "delete"
		case ruleAction42:
			p.InputAttributes.Verb = "list"
		case ruleAction43:
			p.InputAttributes.Verb = "nest"
			p.InputAttributes.ResourceType = "item"
		case ruleAction44:
			p.InputAttributes.Verb = "free"
			p.InputAttributes.ResourceType = "item"
		case ruleAction45:
			p.InputAttributes.Verb = "exists"
		case ruleAction46:
			p.InputAttributes.Verb = "in?"
			p.InputAttributes.ResourceType = "item"
		case ruleAction47:
			p.InputAttributes.Verb = "from?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction48:
			p.InputAttributes.Verb = "to?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction49:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict")
		case ruleAction50:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose")
		case ruleAction51:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids")

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Valid <- <(Command / Response)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if !_rules[rule_]() {
							goto l3
						}
						{
							position5, tokenIndex5 := position, tokenIndex
							{
								position7 := position
								{
									position8, tokenIndex8 := position, tokenIndex
									if !_rules[ruleItem]() {
										goto l9
									}
									{
										position10, tokenIndex10 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l11
										}
										goto l10
									l11:
										position, tokenIndex = position10, tokenIndex10
										if !_rules[ruleSet]() {
											goto l9
										}
									}
								l10:
									if !_rules[ruleIdentifier]() {
										goto l9
									}
									{
										position12, tokenIndex12 := position, tokenIndex
										if !_rules[ruleItemParams]() {
											goto l12
										}
										goto l13
									l12:
										position, tokenIndex = position12, tokenIndex12
									}
								l13:
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l14
									}
									if !_rules[ruleClear]() {
										goto l14
									}
									if !_rules[ruleIdentifier]() {
										goto l14
									}
									{
										position15 := position
										{
											position18 := position
											{
												position19 := position
												{
													position20, tokenIndex20 := position, tokenIndex
													if !_rules[ruleEXTERNAL]() {
														goto l21
													}
													goto l20
												l21:
													position, tokenIndex = position20, tokenIndex20
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l14
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l14
															}
														case 't':
															if !_rules[ruleTYPE]() {
																goto l14
															}
														default:
															if !_rules[ruleNAME]() {
																goto l14
															}
														}
													}

												}
											l20:
												add(rulePegText, position19)
											}
											if !_rules[rule_]() {
												goto l14
											}
											{
												add(ruleAction27, position)
											}
											add(ruleItemKey, position18)
										}
									l16:
										{
											position17, tokenIndex17 := position, tokenIndex
											{
												position24 := position
												{
													position25 := position
													{
														position26, tokenIndex26 := position, tokenIndex
														if !_rules[ruleEXTERNAL]() {
															goto l27
														}
														goto l26
													l27:
														position, tokenIndex = position26, tokenIndex26
														{
															switch buffer[position] {
															case 'e':
																if !_rules[ruleEXPANDED]() {
																	goto l17
																}
															case 'm':
																if !_rules[ruleMECHANISM]() {
																	goto l17
																}
															case 't':
																if !_rules[ruleTYPE]() {
																	goto l17
																}
															default:
																if !_rules[ruleNAME]() {
																	goto l17
																}
															}
														}

													}
												l26:
													add(rulePegText, position25)
												}
												if !_rules[rule_]() {
													goto l17
												}
												{
													add(ruleAction27, position)
												}
												add(ruleItemKey, position24)
											}
											goto l16
										l17:
											position, tokenIndex = position17, tokenIndex17
										}
										add(ruleItemKeys, position15)
									}
									goto l8
								l14:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l30
									}
									if !_rules[ruleDelete]() {
										goto l30
									}
									if !_rules[ruleIdentifier]() {
										goto l30
									}
									goto l8
								l30:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l31
									}
									{
										position32, tokenIndex32 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l33
										}
										goto l32
									l33:
										position, tokenIndex = position32, tokenIndex32
										if !_rules[ruleSet]() {
											goto l31
										}
									}
								l32:
									if !_rules[ruleDualIdentifier]() {
										goto l31
									}
									{
										position34, tokenIndex34 := position, tokenIndex
										if !_rules[ruleRelParams]() {
											goto l34
										}
										goto l35
									l34:
										position, tokenIndex = position34, tokenIndex34
									}
								l35:
									goto l8
								l31:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l36
									}
									if !_rules[ruleClear]() {
										goto l36
									}
									if !_rules[ruleDualIdentifier]() {
										goto l36
									}
									{
										position37 := position
										{
											position40 := position
											{
												position41 := position
												{
													switch buffer[position] {
													case 'e':
														if !_rules[ruleEXPANDED]() {
															goto l36
														}
													case 'a':
														if !_rules[ruleASYNC]() {
															goto l36
														}
													case 'm':
														if !_rules[ruleMECHANISM]() {
															goto l36
														}
													default:
														if !_rules[ruleVERB]() {
															goto l36
														}
													}
												}

												add(rulePegText, position41)
											}
											if !_rules[rule_]() {
												goto l36
											}
											{
												add(ruleAction28, position)
											}
											add(ruleRelKey, position40)
										}
									l38:
										{
											position39, tokenIndex39 := position, tokenIndex
											{
												position44 := position
												{
													position45 := position
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l39
															}
														case 'a':
															if !_rules[ruleASYNC]() {
																goto l39
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l39
															}
														default:
															if !_rules[ruleVERB]() {
																goto l39
															}
														}
													}

													add(rulePegText, position45)
												}
												if !_rules[rule_]() {
													goto l39
												}
												{
													add(ruleAction28, position)
												}
												add(ruleRelKey, position44)
											}
											goto l38
										l39:
											position, tokenIndex = position39, tokenIndex39
										}
										add(ruleRelKeys, position37)
									}
									goto l8
								l36:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l6
									}
									if !_rules[ruleDelete]() {
										goto l6
									}
									if !_rules[ruleDualIdentifier]() {
										goto l6
									}
								}
							l8:
								add(ruleMutation, position7)
							}
							goto l5
						l6:
							position, tokenIndex = position5, tokenIndex5
							{
								position49 := position
								{
									position50, tokenIndex50 := position, tokenIndex
									{
										position52 := position
										if !_rules[ruleFREE]() {
											goto l51
										}
										{
											add(ruleAction44, position)
										}
										add(ruleFree, position52)
									}
									if !_rules[ruleIdentifierList]() {
										goto l51
									}
									goto l50
								l51:
									position, tokenIndex = position50, tokenIndex50
									{
										position54 := position
										if !_rules[ruleNEST]() {
											goto l48
										}
										{
											add(ruleAction43, position)
										}
										add(ruleNest, position54)
									}
									if !_rules[ruleIdentifierList]() {
										goto l48
									}
									if !_rules[rule_]() {
										goto l48
									}
									if !_rules[ruleIN]() {
										goto l48
									}
									{
										position56 := position
										if !_rules[ruleStringLike]() {
											goto l48
										}
										add(rulePegText, position56)
									}
									{
										add(ruleAction2, position)
									}
								}
							l50:
								add(ruleTreeMutation, position49)
							}
							goto l5
						l48:
							position, tokenIndex = position5, tokenIndex5
							{
								position59 := position
								{
									position60, tokenIndex60 := position, tokenIndex
									{
										position62 := position
										{
											switch buffer[position] {
											case 'w':
												{
													position64 := position
													if !_rules[ruleWORLD]() {
														goto l61
													}
													{
														add(ruleAction34, position)
													}
													add(ruleWorld, position64)
												}
												{
													add(ruleAction3, position)
												}
											case 'r':
												if !_rules[ruleRel]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleDualIdentifier]() {
													goto l61
												}
											default:
												if !_rules[ruleItem]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleIdentifier]() {
													goto l61
												}
											}
										}

										add(ruleFetchQuery, position62)
									}
									goto l60
								l61:
									position, tokenIndex = position60, tokenIndex60
									{
										position68 := position
										{
											position69, tokenIndex69 := position, tokenIndex
											{
												position71, tokenIndex71 := position, tokenIndex
												if !_rules[ruleItem]() {
													goto l72
												}
												goto l71
											l72:
												position, tokenIndex = position71, tokenIndex71
												if !_rules[ruleRel]() {
													goto l70
												}
											}
										l71:
											{
												position73 := position
												if !_rules[ruleLIST]() {
													goto l70
												}
												{
													add(ruleAction42, position)
												}
												add(ruleList, position73)
											}
											{
												position75, tokenIndex75 := position, tokenIndex
												{
													position77 := position
													{
														position78 := position
														if !_rules[ruleNumber]() {
															goto l75
														}
														add(rulePegText, position78)
													}
													{
														add(ruleAction14, position)
													}
													add(ruleLimit, position77)
												}
												goto l76
											l75:
												position, tokenIndex = position75, tokenIndex75
											}
										l76:
											goto l69
										l70:
											position, tokenIndex = position69, tokenIndex69
											{
												switch buffer[position] {
												case 'f':
													{
														position81 := position
														if !_rules[ruleFROM_QUERY]() {
															goto l67
														}
														{
															add(ruleAction47, position)
														}
														add(ruleFromQuery, position81)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												case 't':
													{
														position83 := position
														if !_rules[ruleTO_QUERY]() {
															goto l67
														}
														{
															add(ruleAction48, position)
														}
														add(ruleToQuery, position83)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												default:
													if !_rules[ruleItem]() {
														goto l67
													}
													if !_rules[ruleIN]() {
														goto l67
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
													{
														add(ruleAction4, position)
													}
												}
											}

										}
									l69:
										add(ruleListQuery, position68)
									}
									goto l60
								l67:
									position, tokenIndex = position60, tokenIndex60
									{
										position86 := position
										{
											position87, tokenIndex87 := position, tokenIndex
											{
												position89 := position
												if !_rules[ruleIN_QUERY]() {
													goto l88
												}
												{
													add(ruleAction46, position)
												}
												add(ruleInQuery, position89)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l88
											}
											goto l87
										l88:
											position, tokenIndex = position87, tokenIndex87
											{
												position92 := position
												{
													position93, tokenIndex93 := position, tokenIndex
													if !_rules[ruleITEM_EXISTS]() {
														goto l94
													}
													goto l93
												l94:
													position, tokenIndex = position93, tokenIndex93
													if !_rules[ruleItem]() {
														goto l91
													}
													if !_rules[ruleExists]() {
														goto l91
													}
												}
											l93:
												{
													add(ruleAction32, position)
												}
												add(ruleItemExists, position92)
											}
											if !_rules[ruleIdentifier]() {
												goto l91
											}
											goto l87
										l91:
											position, tokenIndex = position87, tokenIndex87
											{
												position96 := position
												{
													position97, tokenIndex97 := position, tokenIndex
													if !_rules[ruleREL_EXISTS]() {
														goto l98
													}
													goto l97
												l98:
													position, tokenIndex = position97, tokenIndex97
													if !_rules[ruleRel]() {
														goto l58
													}
													if !_rules[ruleExists]() {
														goto l58
													}
												}
											l97:
												{
													add(ruleAction33, position)
												}
												add(ruleRelExists, position96)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l58
											}
										}
									l87:
										add(ruleExistsQuery, position86)
									}
								}
							l60:
								add(ruleQuery, position59)
							}
							goto l5
						l58:
							position, tokenIndex = position5, tokenIndex5
							{
								position100 := position
								{
									position101, tokenIndex101 := position, tokenIndex
									{
										position103 := position
										{
											position104, tokenIndex104 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l105
											}
											if !_rules[ruleIdentifier]() {
												goto l105
											}
											{
												position106, tokenIndex106 := position, tokenIndex
												if !_rules[ruleItemParams]() {
													goto l106
												}
												goto l105
											l106:
												position, tokenIndex = position106, tokenIndex106
											}
											goto l104
										l105:
											position, tokenIndex = position104, tokenIndex104
											if !_rules[ruleRel]() {
												goto l102
											}
											if !_rules[ruleDualIdentifier]() {
												goto l102
											}
											{
												position107, tokenIndex107 := position, tokenIndex
												if !_rules[ruleRelParams]() {
													goto l107
												}
												goto l102
											l107:
												position, tokenIndex = position107, tokenIndex107
											}
										}
									l104:
										add(ruleCreateOrFetch, position103)
									}
									{
										add(ruleAction5, position)
									}
									goto l101
								l102:
									position, tokenIndex = position101, tokenIndex101
									{
										position109 := position
										{
											position110, tokenIndex110 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l111
											}
											if !_rules[ruleIdentifier]() {
												goto l111
											}
											if !_rules[ruleItemParams]() {
												goto l111
											}
											goto l110
										l111:
											position, tokenIndex = position110, tokenIndex110
											if !_rules[ruleRel]() {
												goto l3
											}
											if !_rules[ruleDualIdentifier]() {
												goto l3
											}
											if !_rules[ruleRelParams]() {
												goto l3
											}
										}
									l110:
										add(ruleCreateOrSet, position109)
									}
									{
										add(ruleAction6, position)
									}
								}
							l101:
								add(ruleStateBound, position100)
							}
						}
					l5:
					l113:
						{
							position114, tokenIndex114 := position, tokenIndex
							{
								position115 := position
								{
									position116, tokenIndex116 := position, tokenIndex
									{
										position118 := position
										if !_rules[ruleFLAG]() {
											goto l117
										}
										{
											position119 := position
											if buffer[position] != rune('s') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if buffer[position] != rune('r') {
												goto l117
											}
											position++
											if buffer[position] != rune('i') {
												goto l117
											}
											position++
											if buffer[position] != rune('c') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if !_rules[rule_]() {
												goto l117
											}
											add(ruleSTRICT, position119)
										}
										{
											add(ruleAction49, position)
										}
										add(ruleStrictFlag, position118)
									}
									goto l116
								l117:
									position, tokenIndex = position116, tokenIndex116
									{
										position122 := position
										if !_rules[ruleFLAG]() {
											goto l121
										}
										{
											position123 := position
											if buffer[position] != rune('v') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if buffer[position] != rune('r') {
												goto l121
											}
											position++
											if buffer[position] != rune('b') {
												goto l121
											}
											position++
											if buffer[position] != rune('o') {
												goto l121
											}
											position++
											if buffer[position] != rune('s') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if !_rules[rule_]() {
												goto l121
											}
											add(ruleVERBOSE, position123)
										}
										{
											add(ruleAction50, position)
										}
										add(ruleVerboseFlag, position122)
									}
									goto l116
								l121:
									position, tokenIndex = position116, tokenIndex116
									{
										position125 := position
										if !_rules[ruleFLAG]() {
											goto l114
										}
										{
											position126 := position
											if buffer[position] != rune('i') {
												goto l114
											}
											position++
											if buffer[position] != rune('d') {
												goto l114
											}
											position++
											if buffer[position] != rune('s') {
												goto l114
											}
											position++
											if !_rules[rule_]() {
												goto l114
											}
											add(ruleIDS, position126)
										}
										{
											add(ruleAction51, position)
										}
										add(ruleIdsFlag, position125)
									}
								}
							l116:
								add(ruleFlag, position115)
							}
							goto l113
						l114:
							position, tokenIndex = position114, tokenIndex114
						}
						if !_rules[ruleEND]() {
							goto l3
						}
						{
							add(ruleAction1, position)
						}
						add(ruleCommand, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position129 := position
						{
							position130, tokenIndex130 := position, tokenIndex
							{
								position132 := position
								{
									position133, tokenIndex133 := position, tokenIndex
									{
										position135 := position
										{
											position136 := position
											if !_rules[rule_]() {
												goto l134
											}
											if !_rules[ruleDELIMITER]() {
												goto l134
											}
											if !_rules[ruleWORLD]() {
												goto l134
											}
											if !_rules[rule_]() {
												goto l134
											}
											add(ruleBeginWorld, position136)
										}
										if !_rules[ruleTree]() {
											goto l134
										}
									l137:
										{
											position138, tokenIndex138 := position, tokenIndex
											if !_rules[ruleRelObject]() {
												goto l138
											}
											goto l137
										l138:
											position, tokenIndex = position138, tokenIndex138
										}
										{
											position139 := position
											if !_rules[rule_]() {
												goto l134
											}
											if !_rules[ruleENDWORLD]() {
												goto l134
											}
											if !_rules[ruleDELIMITER]() {
												goto l134
											}
											if !_rules[rule_]() {
												goto l134
											}
											add(ruleEndWorld, position139)
										}
										{
											add(ruleAction7, position)
										}
										add(ruleWorldObject, position135)
									}
									goto l133
								l134:
									position, tokenIndex = position133, tokenIndex133
									if !_rules[ruleItemObject]() {
										goto l141
									}
								l142:
									{
										position143, tokenIndex143 := position, tokenIndex
										if !_rules[ruleItemObject]() {
											goto l143
										}
										goto l142
									l143:
										position, tokenIndex = position143, tokenIndex143
									}
									goto l133
								l141:
									position, tokenIndex = position133, tokenIndex133
									if !_rules[ruleRelObject]() {
										goto l144
									}
								l145:
									{
										position146, tokenIndex146 := position, tokenIndex
										if !_rules[ruleRelObject]() {
											goto l146
										}
										goto l145
									l146:
										position, tokenIndex = position146, tokenIndex146
									}
									goto l133
								l144:
									position, tokenIndex = position133, tokenIndex133
									{
										position147 := position
										if !_rules[ruleIdentifierList]() {
											goto l130
										}
										{
											add(ruleAction10, position)
										}
										add(ruleIdentifierListObject, position147)
									}
								}
							l133:
								add(ruleObjects, position132)
							}
							goto l131
						l130:
							position, tokenIndex = position130, tokenIndex130
						}
					l131:
						if !_rules[rule_]() {
							goto l0
						}
						if !_rules[ruleDELIMITER]() {
							goto l0
						}
						if !_rules[ruleDELIMITER]() {
							goto l0
						}
						if !_rules[rule_]() {
							goto l0
						}
						{
							position149 := position
							{
								position150 := position
								{
									position151 := position
									if !_rules[ruleNumber]() {
										goto l0
									}
									add(rulePegText, position151)
								}
								{
									add(ruleAction13, position)
								}
								add(ruleErrCode, position150)
							}
							{
								position153, tokenIndex153 := position, tokenIndex
								if !_rules[ruleERROR]() {
									goto l154
								}
								goto l153
							l154:
								position, tokenIndex = position153, tokenIndex153
								if !_rules[ruleOK]() {
									goto l0
								}
							}
						l153:
							{
								position155 := position
							l156:
								{
									position157, tokenIndex157 := position, tokenIndex
									if !_rules[ruleStringLike]() {
										goto l157
									}
									goto l156
								l157:
									position, tokenIndex = position157, tokenIndex157
								}
								add(rulePegText, position155)
							}
							{
								add(ruleAction12, position)
							}
							add(ruleErrorOrOkay, position149)
						}
						if !_rules[ruleEND]() {
							goto l0
						}
						{
							add(ruleAction0, position)
						}
						add(ruleResponse, position129)
					}
				}
			l2:
				add(ruleValid, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Response <- <(Objects? _ DELIMITER DELIMITER _ ErrorOrOkay END Action0)> */
		nil,
		/* 2 Command <- <(_ (Mutation / TreeMutation / Query / StateBound) Flag* END Action1)> */
		nil,
		/* 3 Mutation <- <((Item (Create / Set) Identifier ItemParams?) / (Item Clear Identifier ItemKeys) / (Item Delete Identifier) / (Rel (Create / Set) DualIdentifier RelParams?) / (Rel Clear DualIdentifier RelKeys) / (Rel Delete DualIdentifier))> */
		nil,
		/* 4 TreeMutation <- <((Free IdentifierList) / (Nest IdentifierList _ IN <StringLike> Action2))> */
		nil,
		/* 5 Query <- <(FetchQuery / ListQuery / ExistsQuery)> */
		nil,
		/* 6 FetchQuery <- <((&('w') (World Action3)) | (&('r') (Rel Fetch DualIdentifier)) | (&('i') (Item Fetch Identifier)))> */
		nil,
		/* 7 ListQuery <- <(((Item / Rel) List Limit?) / ((&('f') (FromQuery Identifier)) | (&('t') (ToQuery Identifier)) | (&('i') (Item IN Identifier Action4))))> */
		nil,
		/* 8 ExistsQuery <- <((InQuery DualIdentifier) / (ItemExists Identifier) / (RelExists DualIdentifier))> */
		nil,
		/* 9 StateBound <- <((CreateOrFetch Action5) / (CreateOrSet Action6))> */
		nil,
		/* 10 CreateOrFetch <- <((Item Identifier !ItemParams) / (Rel DualIdentifier !RelParams))> */
		nil,
		/* 11 CreateOrSet <- <((Item Identifier ItemParams) / (Rel DualIdentifier RelParams))> */
		nil,
		/* 12 Objects <- <(WorldObject / ItemObject+ / RelObject+ / IdentifierListObject)> */
		nil,
		/* 13 WorldObject <- <(BeginWorld Tree RelObject* EndWorld Action7)> */
		nil,
		/* 14 ItemObject <- <(<(Item Identifier ItemParams?)> Action8)> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				{
					position175 := position
					if !_rules[ruleItem]() {
						goto l173
					}
					if !_rules[ruleIdentifier]() {
						goto l173
					}
					{
						position176, tokenIndex176 := position, tokenIndex
						if !_rules[ruleItemParams]() {
							goto l176
						}
						goto l177
					l176:
						position, tokenIndex = position176, tokenIndex176
					}
				l177:
					add(rulePegText, position175)
				}
				{
					add(ruleAction8, position)
				}
				add(ruleItemObject, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 15 RelObject <- <(<(Rel DualIdentifier RelParams?)> Action9)> */
		func() bool {
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				{
					position181 := position
					if !_rules[ruleRel]() {
						goto l179
					}
					if !_rules[ruleDualIdentifier]() {
						goto l179
					}
					{
						position182, tokenIndex182 := position, tokenIndex
						if !_rules[ruleRelParams]() {
							goto l182
						}
						goto l183
					l182:
						position, tokenIndex = position182, tokenIndex182
					}
				l183:
					add(rulePegText, position181)
				}
				{
					add(ruleAction9, position)
				}
				add(ruleRelObject, position180)
			}
			return true
		l179:
			position, tokenIndex = position179, tokenIndex179
			return false
		},
		/* 16 IdentifierListObject <- <(IdentifierList Action10)> */
		nil,
		/* 17 Tree <- <(<('t' 'r' 'e' 'e' '{' (Nil / ItemObject) (':' ':' '[') Tree* (']' '}'))> _ Action11)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188 := position
					if buffer[position] != rune('t') {
						goto l186
					}
					position++
					if buffer[position] != rune('r') {
						goto l186
					}
					position++
					if buffer[position] != rune('e') {
						goto l186
					}
					position++
					if buffer[position] != rune('e') {
						goto l186
					}
					position++
					if buffer[position] != rune('{') {
						goto l186
					}
					position++
					{
						position189, tokenIndex189 := position, tokenIndex
						{
							position191 := position
							if buffer[position] != rune('n') {
								goto l190
							}
							position++
							if buffer[position] != rune('i') {
								goto l190
							}
							position++
							if buffer[position] != rune('l') {
								goto l190
							}
							position++
							add(ruleNil, position191)
						}
						goto l189
					l190:
						position, tokenIndex = position189, tokenIndex189
						if !_rules[ruleItemObject]() {
							goto l186
						}
					}
				l189:
					if buffer[position] != rune(':') {
						goto l186
					}
					position++
					if buffer[position] != rune(':') {
						goto l186
					}
					position++
					if buffer[position] != rune('[') {
						goto l186
					}
					position++
				l192:
					{
						position193, tokenIndex193 := position, tokenIndex
						if !_rules[ruleTree]() {
							goto l193
						}
						goto l192
					l193:
						position, tokenIndex = position193, tokenIndex193
					}
					if buffer[position] != rune(']') {
						goto l186
					}
					position++
					if buffer[position] != rune('}') {
						goto l186
					}
					position++
					add(rulePegText, position188)
				}
				if !_rules[rule_]() {
					goto l186
				}
				{
					add(ruleAction11, position)
				}
				add(ruleTree, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 18 Nil <- <('n' 'i' 'l')> */
		nil,
		/* 19 ErrorOrOkay <- <(ErrCode (ERROR / OK) <StringLike*> Action12)> */
		nil,
		/* 20 ErrCode <- <(<Number> Action13)> */
		nil,
		/* 21 Limit <- <(<Number> Action14)> */
		nil,
		/* 22 Identifier <- <(!Keyword <StringLike> Action15)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[ruleKeyword]() {
						goto l201
					}
					goto l199
				l201:
					position, tokenIndex = position201, tokenIndex201
				}
				{
					position202 := position
					if !_rules[ruleStringLike]() {
						goto l199
					}
					add(rulePegText, position202)
				}
				{
					add(ruleAction15, position)
				}
				add(ruleIdentifier, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 23 SecondIdentifier <- <(!Keyword &Identifier <StringLike> Action16)> */
		nil,
		/* 24 DualIdentifier <- <(Identifier SecondIdentifier)> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				if !_rules[ruleIdentifier]() {
					goto l205
				}
				{
					position207 := position
					{
						position208, tokenIndex208 := position, tokenIndex
						if !_rules[ruleKeyword]() {
							goto l208
						}
						goto l205
					l208:
						position, tokenIndex = position208, tokenIndex208
					}
					{
						position209, tokenIndex209 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l205
						}
						position, tokenIndex = position209, tokenIndex209
					}
					{
						position210 := position
						if !_rules[ruleStringLike]() {
							goto l205
						}
						add(rulePegText, position210)
					}
					{
						add(ruleAction16, position)
					}
					add(ruleSecondIdentifier, position207)
				}
				add(ruleDualIdentifier, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 25 IdentifierList <- <(<(Identifier Identifier*)> Action17)> */
		func() bool {
			position212, tokenIndex212 := position, tokenIndex
			{
				position213 := position
				{
					position214 := position
					if !_rules[ruleIdentifier]() {
						goto l212
					}
				l215:
					{
						position216, tokenIndex216 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l216
						}
						goto l215
					l216:
						position, tokenIndex = position216, tokenIndex216
					}
					add(rulePegText, position214)
				}
				{
					add(ruleAction17, position)
				}
				add(ruleIdentifierList, position213)
			}
			return true
		l212:
			position, tokenIndex = position212, tokenIndex212
			return false
		},
		/* 26 ItemParams <- <ItemParam+> */
		func() bool {
			position218, tokenIndex218 := position, tokenIndex
			{
				position219 := position
				{
					position222 := position
					{
						position223, tokenIndex223 := position, tokenIndex
						if !_rules[ruleEXTERNAL]() {
							goto l224
						}
						if !_rules[ruleEQUALS]() {
							goto l224
						}
						{
							position225 := position
							if !_rules[ruleBoolean]() {
								goto l224
							}
							add(rulePegText, position225)
						}
						{
							add(ruleAction18, position)
						}
						goto l223
					l224:
						position, tokenIndex = position223, tokenIndex223
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l218
								}
								if !_rules[ruleEQUALS]() {
									goto l218
								}
								{
									position228 := position
									if !_rules[ruleStringLike]() {
										goto l218
									}
									add(rulePegText, position228)
								}
								{
									add(ruleAction22, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l218
								}
								if !_rules[ruleEQUALS]() {
									goto l218
								}
								{
									position230 := position
									if !_rules[ruleStringLike]() {
										goto l218
									}
									add(rulePegText, position230)
								}
								{
									add(ruleAction21, position)
								}
							case 'n':
								if !_rules[ruleNAME]() {
									goto l218
								}
								if !_rules[ruleEQUALS]() {
									goto l218
								}
								{
									position232 := position
									if !_rules[ruleStringLike]() {
										goto l218
									}
									add(rulePegText, position232)
								}
								{
									add(ruleAction20, position)
								}
							default:
								if !_rules[ruleTYPE]() {
									goto l218
								}
								if !_rules[ruleEQUALS]() {
									goto l218
								}
								{
									position234 := position
									{
										position235 := position
										{
											position236, tokenIndex236 := position, tokenIndex
											{
												position238 := position
												if buffer[position] != rune('d') {
													goto l237
												}
												position++
												if buffer[position] != rune('a') {
													goto l237
												}
												position++
												if buffer[position] != rune('t') {
													goto l237
												}
												position++
												if buffer[position] != rune('a') {
													goto l237
												}
												position++
												if buffer[position] != rune('b') {
													goto l237
												}
												position++
												if buffer[position] != rune('a') {
													goto l237
												}
												position++
												if buffer[position] != rune('s') {
													goto l237
												}
												position++
												if buffer[position] != rune('e') {
													goto l237
												}
												position++
												if !_rules[rule_]() {
													goto l237
												}
												add(ruleDATABASE, position238)
											}
											goto l236
										l237:
											position, tokenIndex = position236, tokenIndex236
											{
												position240 := position
												if buffer[position] != rune('b') {
													goto l239
												}
												position++
												if buffer[position] != rune('l') {
													goto l239
												}
												position++
												if buffer[position] != rune('o') {
													goto l239
												}
												position++
												if buffer[position] != rune('b') {
													goto l239
												}
												position++
												if buffer[position] != rune('s') {
													goto l239
												}
												position++
												if buffer[position] != rune('t') {
													goto l239
												}
												position++
												if buffer[position] != rune('o') {
													goto l239
												}
												position++
												if buffer[position] != rune('r') {
													goto l239
												}
												position++
												if buffer[position] != rune('e') {
													goto l239
												}
												position++
												if !_rules[rule_]() {
													goto l239
												}
												add(ruleBLOBSTORE, position240)
											}
											goto l236
										l239:
											position, tokenIndex = position236, tokenIndex236
											{
												switch buffer[position] {
												case 'c':
													{
														position242 := position
														if buffer[position] != rune('c') {
															goto l218
														}
														position++
														if buffer[position] != rune('o') {
															goto l218
														}
														position++
														if buffer[position] != rune('d') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleCODE, position242)
													}
												case 'd':
													{
														position243 := position
														if buffer[position] != rune('d') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('v') {
															goto l218
														}
														position++
														if buffer[position] != rune('i') {
															goto l218
														}
														position++
														if buffer[position] != rune('c') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleDEVICE, position243)
													}
												case 's':
													{
														position244 := position
														if buffer[position] != rune('s') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('r') {
															goto l218
														}
														position++
														if buffer[position] != rune('v') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('r') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleSERVER, position244)
													}
												case 'm':
													{
														position245 := position
														if buffer[position] != rune('m') {
															goto l218
														}
														position++
														if buffer[position] != rune('o') {
															goto l218
														}
														position++
														if buffer[position] != rune('b') {
															goto l218
														}
														position++
														if buffer[position] != rune('i') {
															goto l218
														}
														position++
														if buffer[position] != rune('l') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleMOBILE, position245)
													}
												case 'b':
													{
														position246 := position
														if buffer[position] != rune('b') {
															goto l218
														}
														position++
														if buffer[position] != rune('r') {
															goto l218
														}
														position++
														if buffer[position] != rune('o') {
															goto l218
														}
														position++
														if buffer[position] != rune('w') {
															goto l218
														}
														position++
														if buffer[position] != rune('s') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('r') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleBROWSER, position246)
													}
												case 'q':
													{
														position247 := position
														if buffer[position] != rune('q') {
															goto l218
														}
														position++
														if buffer[position] != rune('u') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('u') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(ruleQUEUE, position247)
													}
												default:
													{
														position248 := position
														if buffer[position] != rune('p') {
															goto l218
														}
														position++
														if buffer[position] != rune('e') {
															goto l218
														}
														position++
														if buffer[position] != rune('r') {
															goto l218
														}
														position++
														if buffer[position] != rune('s') {
															goto l218
														}
														position++
														if buffer[position] != rune('o') {
															goto l218
														}
														position++
														if buffer[position] != rune('n') {
															goto l218
														}
														position++
														if !_rules[rule_]() {
															goto l218
														}
														add(rulePERSON, position248)
													}
												}
											}

										}
									l236:
										add(ruleItemType, position235)
									}
									add(rulePegText, position234)
								}
								{
									add(ruleAction19, position)
								}
							}
						}

					}
				l223:
					add(ruleItemParam, position222)
				}
			l220:
				{
					position221, tokenIndex221 := position, tokenIndex
					{
						position250 := position
						{
							position251, tokenIndex251 := position, tokenIndex
							if !_rules[ruleEXTERNAL]() {
								goto l252
							}
							if !_rules[ruleEQUALS]() {
								goto l252
							}
							{
								position253 := position
								if !_rules[ruleBoolean]() {
									goto l252
								}
								add(rulePegText, position253)
							}
							{
								add(ruleAction18, position)
							}
							goto l251
						l252:
							position, tokenIndex = position251, tokenIndex251
							{
								switch buffer[position] {
								case 'e':
									if !_rules[ruleEXPANDED]() {
										goto l221
									}
									if !_rules[ruleEQUALS]() {
										goto l221
									}
									{
										position256 := position
										if !_rules[ruleStringLike]() {
											goto l221
										}
										add(rulePegText, position256)
									}
									{
										add(ruleAction22, position)
									}
								case 'm':
									if !_rules[ruleMECHANISM]() {
										goto l221
									}
									if !_rules[ruleEQUALS]() {
										goto l221
									}
									{
										position258 := position
										if !_rules[ruleStringLike]() {
											goto l221
										}
										add(rulePegText, position258)
									}
									{
										add(ruleAction21, position)
									}
								case 'n':
									if !_rules[ruleNAME]() {
										goto l221
									}
									if !_rules[ruleEQUALS]() {
										goto l221
									}
									{
										position260 := position
										if !_rules[ruleStringLike]() {
											goto l221
										}
										add(rulePegText, position260)
									}
									{
										add(ruleAction20, position)
									}
								default:
									if !_rules[ruleTYPE]() {
										goto l221
									}
									if !_rules[ruleEQUALS]() {
										goto l221
									}
									{
										position262 := position
										{
											position263 := position
											{
												position264, tokenIndex264 := position, tokenIndex
												{
													position266 := position
													if buffer[position] != rune('d') {
														goto l265
													}
													position++
													if buffer[position] != rune('a') {
														goto l265
													}
													position++
													if buffer[position] != rune('t') {
														goto l265
													}
													position++
													if buffer[position] != rune('a') {
														goto l265
													}
													position++
													if buffer[position] != rune('b') {
														goto l265
													}
													position++
													if buffer[position] != rune('a') {
														goto l265
													}
													position++
													if buffer[position] != rune('s') {
														goto l265
													}
													position++
													if buffer[position] != rune('e') {
														goto l265
													}
													position++
													if !_rules[rule_]() {
														goto l265
													}
													add(ruleDATABASE, position266)
												}
												goto l264
											l265:
												position, tokenIndex = position264, tokenIndex264
												{
													position268 := position
													if buffer[position] != rune('b') {
														goto l267
													}
													position++
													if buffer[position] != rune('l') {
														goto l267
													}
													position++
													if buffer[position] != rune('o') {
														goto l267
													}
													position++
													if buffer[position] != rune('b') {
														goto l267
													}
													position++
													if buffer[position] != rune('s') {
														goto l267
													}
													position++
													if buffer[position] != rune('t') {
														goto l267
													}
													position++
													if buffer[position] != rune('o') {
														goto l267
													}
													position++
													if buffer[position] != rune('r') {
														goto l267
													}
													position++
													if buffer[position] != rune('e') {
														goto l267
													}
													position++
													if !_rules[rule_]() {
														goto l267
													}
													add(ruleBLOBSTORE, position268)
												}
												goto l264
											l267:
												position, tokenIndex = position264, tokenIndex264
												{
													switch buffer[position] {
													case 'c':
														{
															position270 := position
															if buffer[position] != rune('c') {
																goto l221
															}
															position++
															if buffer[position] != rune('o') {
																goto l221
															}
															position++
															if buffer[position] != rune('d') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleCODE, position270)
														}
													case 'd':
														{
															position271 := position
															if buffer[position] != rune('d') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('v') {
																goto l221
															}
															position++
															if buffer[position] != rune('i') {
																goto l221
															}
															position++
															if buffer[position] != rune('c') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleDEVICE, position271)
														}
													case 's':
														{
															position272 := position
															if buffer[position] != rune('s') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('r') {
																goto l221
															}
															position++
															if buffer[position] != rune('v') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('r') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleSERVER, position272)
														}
													case 'm':
														{
															position273 := position
															if buffer[position] != rune('m') {
																goto l221
															}
															position++
															if buffer[position] != rune('o') {
																goto l221
															}
															position++
															if buffer[position] != rune('b') {
																goto l221
															}
															position++
															if buffer[position] != rune('i') {
																goto l221
															}
															position++
															if buffer[position] != rune('l') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleMOBILE, position273)
														}
													case 'b':
														{
															position274 := position
															if buffer[position] != rune('b') {
																goto l221
															}
															position++
															if buffer[position] != rune('r') {
																goto l221
															}
															position++
															if buffer[position] != rune('o') {
																goto l221
															}
															position++
															if buffer[position] != rune('w') {
																goto l221
															}
															position++
															if buffer[position] != rune('s') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('r') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleBROWSER, position274)
														}
													case 'q':
														{
															position275 := position
															if buffer[position] != rune('q') {
																goto l221
															}
															position++
															if buffer[position] != rune('u') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('u') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(ruleQUEUE, position275)
														}
													default:
														{
															position276 := position
															if buffer[position] != rune('p') {
																goto l221
															}
															position++
															if buffer[position] != rune('e') {
																goto l221
															}
															position++
															if buffer[position] != rune('r') {
																goto l221
															}
															position++
															if buffer[position] != rune('s') {
																goto l221
															}
															position++
															if buffer[position] != rune('o') {
																goto l221
															}
															position++
															if buffer[position] != rune('n') {
																goto l221
															}
															position++
															if !_rules[rule_]() {
																goto l221
															}
															add(rulePERSON, position276)
														}
													}
												}

											}
										l264:
											add(ruleItemType, position263)
										}
										add(rulePegText, position262)
									}
									{
										add(ruleAction19, position)
									}
								}
							}

						}
					l251:
						add(ruleItemParam, position250)
					}
					goto l220
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
				add(ruleItemParams, position219)
			}
			return true
		l218:
			position, tokenIndex = position218, tokenIndex218
			return false
		},
		/* 27 RelParams <- <RelParam+> */
		func() bool {
			position278, tokenIndex278 := position, tokenIndex
			{
				position279 := position
				{
					position282 := position
					{
						switch buffer[position] {
						case 'e':
							if !_rules[ruleEXPANDED]() {
								goto l278
							}
							if !_rules[ruleEQUALS]() {
								goto l278
							}
							{
								position284 := position
								if !_rules[ruleStringLike]() {
									goto l278
								}
								add(rulePegText, position284)
							}
							{
								add(ruleAction26, position)
							}
						case 'a':
							if !_rules[ruleASYNC]() {
								goto l278
							}
							if !_rules[ruleEQUALS]() {
								goto l278
							}
							{
								position286 := position
								if !_rules[ruleBoolean]() {
									goto l278
								}
								add(rulePegText, position286)
							}
							{
								add(ruleAction25, position)
							}
						case 'm':
							if !_rules[ruleMECHANISM]() {
								goto l278
							}
							if !_rules[ruleEQUALS]() {
								goto l278
							}
							{
								position288 := position
								if !_rules[ruleStringLike]() {
									goto l278
								}
								add(rulePegText, position288)
							}
							{
								add(ruleAction24, position)
							}
						default:
							if !_rules[ruleVERB]() {
								goto l278
							}
							if !_rules[ruleEQUALS]() {
								goto l278
							}
							{
								position290 := position
								if !_rules[ruleStringLike]() {
									goto l278
								}
								add(rulePegText, position290)
							}
							{
								add(ruleAction23, position)
							}
						}
					}

					add(ruleRelParam, position282)
				}
			l280:
				{
					position281, tokenIndex281 := position, tokenIndex
					{
						position292 := position
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l281
								}
								if !_rules[ruleEQUALS]() {
									goto l281
								}
								{
									position294 := position
									if !_rules[ruleStringLike]() {
										goto l281
									}
									add(rulePegText, position294)
								}
								{
									add(ruleAction26, position)
								}
							case 'a':
								if !_rules[ruleASYNC]() {
									goto l281
								}
								if !_rules[ruleEQUALS]() {
									goto l281
								}
								{
									position296 := position
									if !_rules[ruleBoolean]() {
										goto l281
									}
									add(rulePegText, position296)
								}
								{
									add(ruleAction25, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l281
								}
								if !_rules[ruleEQUALS]() {
									goto l281
								}
								{
									position298 := position
									if !_rules[ruleStringLike]() {
										goto l281
									}
									add(rulePegText, position298)
								}
								{
									add(ruleAction24, position)
								}
							default:
								if !_rules[ruleVERB]() {
									goto l281
								}
								if !_rules[ruleEQUALS]() {
									goto l281
								}
								{
									position300 := position
									if !_rules[ruleStringLike]() {
										goto l281
									}
									add(rulePegText, position300)
								}
								{
									add(ruleAction23, position)
								}
							}
						}

						add(ruleRelParam, position292)
					}
					goto l280
				l281:
					position, tokenIndex = position281, tokenIndex281
				}
				add(ruleRelParams, position279)
			}
			return true
		l278:
			position, tokenIndex = position278, tokenIndex278
			return false
		},
		/* 28 ItemParam <- <((EXTERNAL EQUALS <Boolean> Action18) / ((&('e') (EXPANDED EQUALS <StringLike> Action22)) | (&('m') (MECHANISM EQUALS <StringLike> Action21)) | (&('n') (NAME EQUALS <StringLike> Action20)) | (&('t') (TYPE EQUALS <ItemType> Action19))))> */
		nil,
		/* 29 RelParam <- <((&('e') (EXPANDED EQUALS <StringLike> Action26)) | (&('a') (ASYNC EQUALS <Boolean> Action25)) | (&('m') (MECHANISM EQUALS <StringLike> Action24)) | (&('v') (VERB EQUALS <StringLike> Action23)))> */
		nil,
		/* 30 ItemKeys <- <ItemKey+> */
		nil,
		/* 31 RelKeys <- <RelKey+> */
		nil,
		/* 32 ItemKey <- <(<(EXTERNAL / ((&('e') EXPANDED) | (&('m') MECHANISM) | (&('t') TYPE) | (&('n') NAME)))> _ Action27)> */
		nil,
		/* 33 RelKey <- <(<((&('e') EXPANDED) | (&('a') ASYNC) | (&('m') MECHANISM) | (&('v') VERB))> _ Action28)> */
		nil,
		/* 34 StringLike <- <(<(Text / QuotedText)> _ Action29)> */
		func() bool {
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				{
					position310 := position
					{
						position311, tokenIndex311 := position, tokenIndex
						{
							position313 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l312
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l312
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l312
									}
									position++
								case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l312
									}
									position++
								default:
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l312
									}
									position++
								}
							}

						l314:
							{
								position315, tokenIndex315 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l315
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l315
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l315
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l315
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l315
										}
										position++
									}
								}

								goto l314
							l315:
								position, tokenIndex = position315, tokenIndex315
							}
							add(ruleText, position313)
						}
						goto l311
					l312:
						position, tokenIndex = position311, tokenIndex311
						{
							position318 := position
							if !_rules[ruleQUOTE]() {
								goto l308
							}
						l319:
							{
								position320, tokenIndex320 := position, tokenIndex
								{
									switch buffer[position] {
									case ' ':
										if buffer[position] != rune(' ') {
											goto l320
										}
										position++
									case ':':
										if buffer[position] != rune(':') {
											goto l320
										}
										position++
									case ';':
										if buffer[position] != rune(';') {
											goto l320
										}
										position++
									case '~':
										if buffer[position] != rune('~') {
											goto l320
										}
										position++
									case '=':
										if buffer[position] != rune('=') {
											goto l320
										}
										position++
									case '+':
										if buffer[position] != rune('+') {
											goto l320
										}
										position++
									case ']':
										if buffer[position] != rune(']') {
											goto l320
										}
										position++
									case '[':
										if buffer[position] != rune('[') {
											goto l320
										}
										position++
									case ')':
										if buffer[position] != rune(')') {
											goto l320
										}
										position++
									case '(':
										if buffer[position] != rune('(') {
											goto l320
										}
										position++
									case '*':
										if buffer[position] != rune('*') {
											goto l320
										}
										position++
									case '&':
										if buffer[position] != rune('&') {
											goto l320
										}
										position++
									case '^':
										if buffer[position] != rune('^') {
											goto l320
										}
										position++
									case '%':
										if buffer[position] != rune('%') {
											goto l320
										}
										position++
									case '$':
										if buffer[position] != rune('$') {
											goto l320
										}
										position++
									case '#':
										if buffer[position] != rune('#') {
											goto l320
										}
										position++
									case '@':
										if buffer[position] != rune('@') {
											goto l320
										}
										position++
									case '!':
										if buffer[position] != rune('!') {
											goto l320
										}
										position++
									case ',':
										if buffer[position] != rune(',') {
											goto l320
										}
										position++
									case '.':
										if buffer[position] != rune('.') {
											goto l320
										}
										position++
									case '_':
										if buffer[position] != rune('_') {
											goto l320
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l320
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l320
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l320
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l320
										}
										position++
									}
								}

								goto l319
							l320:
								position, tokenIndex = position320, tokenIndex320
							}
							if !_rules[ruleQUOTE]() {
								goto l308
							}
							add(ruleQuotedText, position318)
						}
					}
				l311:
					add(rulePegText, position310)
				}
				if !_rules[rule_]() {
					goto l308
				}
				{
					add(ruleAction29, position)
				}
				add(ruleStringLike, position309)
			}
			return true
		l308:
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 35 Number <- <(<[0-9]+> _ Action30)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				{
					position325 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l323
					}
					position++
				l326:
					{
						position327, tokenIndex327 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l327
						}
						position++
						goto l326
					l327:
						position, tokenIndex = position327, tokenIndex327
					}
					add(rulePegText, position325)
				}
				if !_rules[rule_]() {
					goto l323
				}
				{
					add(ruleAction30, position)
				}
				add(ruleNumber, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 36 Boolean <- <(<(TRUE / FALSE)> Action31)> */
		func() bool {
			position329, tokenIndex329 := position, tokenIndex
			{
				position330 := position
				{
					position331 := position
					{
						position332, tokenIndex332 := position, tokenIndex
						{
							position334 := position
							if buffer[position] != rune('t') {
								goto l333
							}
							position++
							if buffer[position] != rune('r') {
								goto l333
							}
							position++
							if buffer[position] != rune('u') {
								goto l333
							}
							position++
							if buffer[position] != rune('e') {
								goto l333
							}
							position++
							if !_rules[rule_]() {
								goto l333
							}
							add(ruleTRUE, position334)
						}
						goto l332
					l333:
						position, tokenIndex = position332, tokenIndex332
						{
							position335 := position
							if buffer[position] != rune('f') {
								goto l329
							}
							position++
							if buffer[position] != rune('a') {
								goto l329
							}
							position++
							if buffer[position] != rune('l') {
								goto l329
							}
							position++
							if buffer[position] != rune('s') {
								goto l329
							}
							position++
							if buffer[position] != rune('e') {
								goto l329
							}
							position++
							if !_rules[rule_]() {
								goto l329
							}
							add(ruleFALSE, position335)
						}
					}
				l332:
					add(rulePegText, position331)
				}
				{
					add(ruleAction31, position)
				}
				add(ruleBoolean, position330)
			}
			return true
		l329:
			position, tokenIndex = position329, tokenIndex329
			return false
		},
		/* 37 Text <- <((&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> */
		nil,
		/* 38 QuotedText <- <(QUOTE ((&(' ') ' ') | (&(':') ':') | (&(';') ';') | (&('~') '~') | (&('=') '=') | (&('+') '+') | (&(']') ']') | (&('[') '[') | (&(')') ')') | (&('(') '(') | (&('*') '*') | (&('&') '&') | (&('^') '^') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('@') '@') | (&('!') '!') | (&(',') ',') | (&('.') '.') | (&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))* QUOTE)> */
		nil,
		/* 39 ItemExists <- <((ITEM_EXISTS / (Item Exists)) Action32)> */
		nil,
		/* 40 RelExists <- <((REL_EXISTS / (Rel Exists)) Action33)> */
		nil,
		/* 41 World <- <(WORLD Action34)> */
		nil,
		/* 42 Item <- <(ITEM Action35)> */
		func() bool {
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				if !_rules[ruleITEM]() {
					goto l342
				}
				{
					add(ruleAction35, position)
				}
				add(ruleItem, position343)
			}
			return true
		l342:
			position, tokenIndex = position342, tokenIndex342
			return false
		},
		/* 43 Rel <- <(REL Action36)> */
		func() bool {
			position345, tokenIndex345 := position, tokenIndex
			{
				position346 := position
				if !_rules[ruleREL]() {
					goto l345
				}
				{
					add(ruleAction36, position)
				}
				add(ruleRel, position346)
			}
			return true
		l345:
			position, tokenIndex = position345, tokenIndex345
			return false
		},
		/* 44 Create <- <(CREATE Action37)> */
		func() bool {
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				if !_rules[ruleCREATE]() {
					goto l348
				}
				{
					add(ruleAction37, position)
				}
				add(ruleCreate, position349)
			}
			return true
		l348:
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 45 Fetch <- <(FETCH Action38)> */
		func() bool {
			position351, tokenIndex351 := position, tokenIndex
			{
				position352 := position
				if !_rules[ruleFETCH]() {
					goto l351
				}
				{
					add(ruleAction38, position)
				}
				add(ruleFetch, position352)
			}
			return true
		l351:
			position, tokenIndex = position351, tokenIndex351
			return false
		},
		/* 46 Set <- <(SET Action39)> */
		func() bool {
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				if !_rules[ruleSET]() {
					goto l354
				}
				{
					add(ruleAction39, position)
				}
				add(ruleSet, position355)
			}
			return true
		l354:
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 47 Clear <- <(CLEAR Action40)> */
		func() bool {
			position357, tokenIndex357 := position, tokenIndex
			{
				position358 := position
				if !_rules[ruleCLEAR]() {
					goto l357
				}
				{
					add(ruleAction40, position)
				}
				add(ruleClear, position358)
			}
			return true
		l357:
			position, tokenIndex = position357, tokenIndex357
			return false
		},
		/* 48 Delete <- <(DELETE Action41)> */
		func() bool {
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				if !_rules[ruleDELETE]() {
					goto l360
				}
				{
					add(ruleAction41, position)
				}
				add(ruleDelete, position361)
			}
			return true
		l360:
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 49 List <- <(LIST Action42)> */
		nil,
		/* 50 Nest <- <(NEST Action43)> */
		nil,
		/* 51 Free <- <(FREE Action44)> */
		nil,
		/* 52 Exists <- <(EXISTS Action45)> */
		func() bool {
			position366, tokenIndex366 := position, tokenIndex
			{
				position367 := position
				if !_rules[ruleEXISTS]() {
					goto l366
				}
				{
					add(ruleAction45, position)
				}
				add(ruleExists, position367)
			}
			return true
		l366:
			position, tokenIndex = position366, tokenIndex366
			return false
		},
		/* 53 InQuery <- <(IN_QUERY Action46)> */
		nil,
		/* 54 FromQuery <- <(FROM_QUERY Action47)> */
		nil,
		/* 55 ToQuery <- <(TO_QUERY Action48)> */
		nil,
		/* 56 Flag <- <(StrictFlag / VerboseFlag / IdsFlag)> */
		nil,
		/* 57 StrictFlag <- <(FLAG STRICT Action49)> */
		nil,
		/* 58 VerboseFlag <- <(FLAG VERBOSE Action50)> */
		nil,
		/* 59 IdsFlag <- <(FLAG IDS Action51)> */
		nil,
		/* 60 BeginWorld <- <(_ DELIMITER WORLD _)> */
		nil,
		/* 61 EndWorld <- <(_ ENDWORLD DELIMITER _)> */
		nil,
		/* 62 ItemType <- <(DATABASE / BLOBSTORE / ((&('c') CODE) | (&('d') DEVICE) | (&('s') SERVER) | (&('m') MOBILE) | (&('b') BROWSER) | (&('q') QUEUE) | (&('p') PERSON)))> */
		nil,
		/* 63 Keyword <- <(ENDWORLD / ERROR / ITEM / ITEM_EXISTS / REL / FROM_QUERY / IN / CREATE / FETCH / ((&('$') DELIMITER) | (&('-') FLAG) | (&('n') NEST) | (&('f') FREE) | (&('e') EXISTS) | (&('l') LIST) | (&('c') CLEAR) | (&('s') SET) | (&('d') DELETE) | (&('i') IN_QUERY) | (&('t') TO_QUERY) | (&('r') REL_EXISTS) | (&('o') OK) | (&('w') WORLD)))> */
		func() bool {
			position379, tokenIndex379 := position, tokenIndex
			{
				position380 := position
				{
					position381, tokenIndex381 := position, tokenIndex
					if !_rules[ruleENDWORLD]() {
						goto l382
					}
					goto l381
				l382:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleERROR]() {
						goto l383
					}
					goto l381
				l383:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleITEM]() {
						goto l384
					}
					goto l381
				l384:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleITEM_EXISTS]() {
						goto l385
					}
					goto l381
				l385:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleREL]() {
						goto l386
					}
					goto l381
				l386:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleFROM_QUERY]() {
						goto l387
					}
					goto l381
				l387:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleIN]() {
						goto l388
					}
					goto l381
				l388:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleCREATE]() {
						goto l389
					}
					goto l381
				l389:
					position, tokenIndex = position381, tokenIndex381
					if !_rules[ruleFETCH]() {
						goto l390
					}
					goto l381
				l390:
					position, tokenIndex = position381, tokenIndex381
					{
						switch buffer[position] {
						case '$':
							if !_rules[ruleDELIMITER]() {
								goto l379
							}
						case '-':
							if !_rules[ruleFLAG]() {
								goto l379
							}
						case 'n':
							if !_rules[ruleNEST]() {
								goto l379
							}
						case 'f':
							if !_rules[ruleFREE]() {
								goto l379
							}
						case 'e':
							if !_rules[ruleEXISTS]() {
								goto l379
							}
						case 'l':
							if !_rules[ruleLIST]() {
								goto l379
							}
						case 'c':
							if !_rules[ruleCLEAR]() {
								goto l379
							}
						case 's':
							if !_rules[ruleSET]() {
								goto l379
							}
						case 'd':
							if !_rules[ruleDELETE]() {
								goto l379
							}
						case 'i':
							if !_rules[ruleIN_QUERY]() {
								goto l379
							}
						case 't':
							if !_rules[ruleTO_QUERY]() {
								goto l379
							}
						case 'r':
							if !_rules[ruleREL_EXISTS]() {
								goto l379
							}
						case 'o':
							if !_rules[ruleOK]() {
								goto l379
							}
						default:
							if !_rules[ruleWORLD]() {
								goto l379
							}
						}
					}

				}
			l381:
				add(ruleKeyword, position380)
			}
			return true
		l379:
			position, tokenIndex = position379, tokenIndex379
			return false
		},
		/* 64 WORLD <- <('w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position392, tokenIndex392 := position, tokenIndex
			{
				position393 := position
				if buffer[position] != rune('w') {
					goto l392
				}
				position++
				if buffer[position] != rune('o') {
					goto l392
				}
				position++
				if buffer[position] != rune('r') {
					goto l392
				}
				position++
				if buffer[position] != rune('l') {
					goto l392
				}
				position++
				if buffer[position] != rune('d') {
					goto l392
				}
				position++
				if !_rules[rule_]() {
					goto l392
				}
				add(ruleWORLD, position393)
			}
			return true
		l392:
			position, tokenIndex = position392, tokenIndex392
			return false
		},
		/* 65 ENDWORLD <- <('e' 'n' 'd' 'w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position394, tokenIndex394 := position, tokenIndex
			{
				position395 := position
				if buffer[position] != rune('e') {
					goto l394
				}
				position++
				if buffer[position] != rune('n') {
					goto l394
				}
				position++
				if buffer[position] != rune('d') {
					goto l394
				}
				position++
				if buffer[position] != rune('w') {
					goto l394
				}
				position++
				if buffer[position] != rune('o') {
					goto l394
				}
				position++
				if buffer[position] != rune('r') {
					goto l394
				}
				position++
				if buffer[position] != rune('l') {
					goto l394
				}
				position++
				if buffer[position] != rune('d') {
					goto l394
				}
				position++
				if !_rules[rule_]() {
					goto l394
				}
				add(ruleENDWORLD, position395)
			}
			return true
		l394:
			position, tokenIndex = position394, tokenIndex394
			return false
		},
		/* 66 ERROR <- <('e' 'r' 'r' 'o' 'r' _)> */
		func() bool {
			position396, tokenIndex396 := position, tokenIndex
			{
				position397 := position
				if buffer[position] != rune('e') {
					goto l396
				}
				position++
				if buffer[position] != rune('r') {
					goto l396
				}
				position++
				if buffer[position] != rune('r') {
					goto l396
				}
				position++
				if buffer[position] != rune('o') {
					goto l396
				}
				position++
				if buffer[position] != rune('r') {
					goto l396
				}
				position++
				if !_rules[rule_]() {
					goto l396
				}
				add(ruleERROR, position397)
			}
			return true
		l396:
			position, tokenIndex = position396, tokenIndex396
			return false
		},
		/* 67 OK <- <('o' 'k' _)> */
		func() bool {
			position398, tokenIndex398 := position, tokenIndex
			{
				position399 := position
				if buffer[position] != rune('o') {
					goto l398
				}
				position++
				if buffer[position] != rune('k') {
					goto l398
				}
				position++
				if !_rules[rule_]() {
					goto l398
				}
				add(ruleOK, position399)
			}
			return true
		l398:
			position, tokenIndex = position398, tokenIndex398
			return false
		},
		/* 68 ITEM <- <('i' 't' 'e' 'm' 's'? _)> */
		func() bool {
			position400, tokenIndex400 := position, tokenIndex
			{
				position401 := position
				if buffer[position] != rune('i') {
					goto l400
				}
				position++
				if buffer[position] != rune('t') {
					goto l400
				}
				position++
				if buffer[position] != rune('e') {
					goto l400
				}
				position++
				if buffer[position] != rune('m') {
					goto l400
				}
				position++
				{
					position402, tokenIndex402 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l402
					}
					position++
					goto l403
				l402:
					position, tokenIndex = position402, tokenIndex402
				}
			l403:
				if !_rules[rule_]() {
					goto l400
				}
				add(ruleITEM, position401)
			}
			return true
		l400:
			position, tokenIndex = position400, tokenIndex400
			return false
		},
		/* 69 ITEM_EXISTS <- <('i' 't' 'e' 'm' '?' _)> */
		func() bool {
			position404, tokenIndex404 := position, tokenIndex
			{
				position405 := position
				if buffer[position] != rune('i') {
					goto l404
				}
				position++
				if buffer[position] != rune('t') {
					goto l404
				}
				position++
				if buffer[position] != rune('e') {
					goto l404
				}
				position++
				if buffer[position] != rune('m') {
					goto l404
				}
				position++
				if buffer[position] != rune('?') {
					goto l404
				}
				position++
				if !_rules[rule_]() {
					goto l404
				}
				add(ruleITEM_EXISTS, position405)
			}
			return true
		l404:
			position, tokenIndex = position404, tokenIndex404
			return false
		},
		/* 70 REL <- <('r' 'e' 'l' 's'? _)> */
		func() bool {
			position406, tokenIndex406 := position, tokenIndex
			{
				position407 := position
				if buffer[position] != rune('r') {
					goto l406
				}
				position++
				if buffer[position] != rune('e') {
					goto l406
				}
				position++
				if buffer[position] != rune('l') {
					goto l406
				}
				position++
				{
					position408, tokenIndex408 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l408
					}
					position++
					goto l409
				l408:
					position, tokenIndex = position408, tokenIndex408
				}
			l409:
				if !_rules[rule_]() {
					goto l406
				}
				add(ruleREL, position407)
			}
			return true
		l406:
			position, tokenIndex = position406, tokenIndex406
			return false
		},
		/* 71 REL_EXISTS <- <('r' 'e' 'l' '?' _)> */
		func() bool {
			position410, tokenIndex410 := position, tokenIndex
			{
				position411 := position
				if buffer[position] != rune('r') {
					goto l410
				}
				position++
				if buffer[position] != rune('e') {
					goto l410
				}
				position++
				if buffer[position] != rune('l') {
					goto l410
				}
				position++
				if buffer[position] != rune('?') {
					goto l410
				}
				position++
				if !_rules[rule_]() {
					goto l410
				}
				add(ruleREL_EXISTS, position411)
			}
			return true
		l410:
			position, tokenIndex = position410, tokenIndex410
			return false
		},
		/* 72 FROM_QUERY <- <('f' 'r' 'o' 'm' '?' _)> */
		func() bool {
			position412, tokenIndex412 := position, tokenIndex
			{
				position413 := position
				if buffer[position] != rune('f') {
					goto l412
				}
				position++
				if buffer[position] != rune('r') {
					goto l412
				}
				position++
				if buffer[position] != rune('o') {
					goto l412
				}
				position++
				if buffer[position] != rune('m') {
					goto l412
				}
				position++
				if buffer[position] != rune('?') {
					goto l412
				}
				position++
				if !_rules[rule_]() {
					goto l412
				}
				add(ruleFROM_QUERY, position413)
			}
			return true
		l412:
			position, tokenIndex = position412, tokenIndex412
			return false
		},
		/* 73 TO_QUERY <- <('t' 'o' '?' _)> */
		func() bool {
			position414, tokenIndex414 := position, tokenIndex
			{
				position415 := position
				if buffer[position] != rune('t') {
					goto l414
				}
				position++
				if buffer[position] != rune('o') {
					goto l414
				}
				position++
				if buffer[position] != rune('?') {
					goto l414
				}
				position++
				if !_rules[rule_]() {
					goto l414
				}
				add(ruleTO_QUERY, position415)
			}
			return true
		l414:
			position, tokenIndex = position414, tokenIndex414
			return false
		},
		/* 74 IN <- <('i' 'n' _)> */
		func() bool {
			position416, tokenIndex416 := position, tokenIndex
			{
				position417 := position
				if buffer[position] != rune('i') {
					goto l416
				}
				position++
				if buffer[position] != rune('n') {
					goto l416
				}
				position++
				if !_rules[rule_]() {
					goto l416
				}
				add(ruleIN, position417)
			}
			return true
		l416:
			position, tokenIndex = position416, tokenIndex416
			return false
		},
		/* 75 IN_QUERY <- <('i' 'n' '?' _)> */
		func() bool {
			position418, tokenIndex418 := position, tokenIndex
			{
				position419 := position
				if buffer[position] != rune('i') {
					goto l418
				}
				position++
				if buffer[position] != rune('n') {
					goto l418
				}
				position++
				if buffer[position] != rune('?') {
					goto l418
				}
				position++
				if !_rules[rule_]() {
					goto l418
				}
				add(ruleIN_QUERY, position419)
			}
			return true
		l418:
			position, tokenIndex = position418, tokenIndex418
			return false
		},
		/* 76 CREATE <- <('c' 'r' 'e' 'a' 't' 'e' _)> */
		func() bool {
			position420, tokenIndex420 := position, tokenIndex
			{
				position421 := position
				if buffer[position] != rune('c') {
					goto l420
				}
				position++
				if buffer[position] != rune('r') {
					goto l420
				}
				position++
				if buffer[position] != rune('e') {
					goto l420
				}
				position++
				if buffer[position] != rune('a') {
					goto l420
				}
				position++
				if buffer[position] != rune('t') {
					goto l420
				}
				position++
				if buffer[position] != rune('e') {
					goto l420
				}
				position++
				if !_rules[rule_]() {
					goto l420
				}
				add(ruleCREATE, position421)
			}
			return true
		l420:
			position, tokenIndex = position420, tokenIndex420
			return false
		},
		/* 77 DELETE <- <('d' 'e' 'l' 'e' 't' 'e' _)> */
		func() bool {
			position422, tokenIndex422 := position, tokenIndex
			{
				position423 := position
				if buffer[position] != rune('d') {
					goto l422
				}
				position++
				if buffer[position] != rune('e') {
					goto l422
				}
				position++
				if buffer[position] != rune('l') {
					goto l422
				}
				position++
				if buffer[position] != rune('e') {
					goto l422
				}
				position++
				if buffer[position] != rune('t') {
					goto l422
				}
				position++
				if buffer[position] != rune('e') {
					goto l422
				}
				position++
				if !_rules[rule_]() {
					goto l422
				}
				add(ruleDELETE, position423)
			}
			return true
		l422:
			position, tokenIndex = position422, tokenIndex422
			return false
		},
		/* 78 SET <- <('s' 'e' 't' _)> */
		func() bool {
			position424, tokenIndex424 := position, tokenIndex
			{
				position425 := position
				if buffer[position] != rune('s') {
					goto l424
				}
				position++
				if buffer[position] != rune('e') {
					goto l424
				}
				position++
				if buffer[position] != rune('t') {
					goto l424
				}
				position++
				if !_rules[rule_]() {
					goto l424
				}
				add(ruleSET, position425)
			}
			return true
		l424:
			position, tokenIndex = position424, tokenIndex424
			return false
		},
		/* 79 CLEAR <- <('c' 'l' 'e' 'a' 'r' _)> */
		func() bool {
			position426, tokenIndex426 := position, tokenIndex
			{
				position427 := position
				if buffer[position] != rune('c') {
					goto l426
				}
				position++
				if buffer[position] != rune('l') {
					goto l426
				}
				position++
				if buffer[position] != rune('e') {
					goto l426
				}
				position++
				if buffer[position] != rune('a') {
					goto l426
				}
				position++
				if buffer[position] != rune('r') {
					goto l426
				}
				position++
				if !_rules[rule_]() {
					goto l426
				}
				add(ruleCLEAR, position427)
			}
			return true
		l426:
			position, tokenIndex = position426, tokenIndex426
			return false
		},
		/* 80 FETCH <- <('f' 'e' 't' 'c' 'h' _)> */
		func() bool {
			position428, tokenIndex428 := position, tokenIndex
			{
				position429 := position
				if buffer[position] != rune('f') {
					goto l428
				}
				position++
				if buffer[position] != rune('e') {
					goto l428
				}
				position++
				if buffer[position] != rune('t') {
					goto l428
				}
				position++
				if buffer[position] != rune('c') {
					goto l428
				}
				position++
				if buffer[position] != rune('h') {
					goto l428
				}
				position++
				if !_rules[rule_]() {
					goto l428
				}
				add(ruleFETCH, position429)
			}
			return true
		l428:
			position, tokenIndex = position428, tokenIndex428
			return false
		},
		/* 81 LIST <- <('l' 'i' 's' 't' _)> */
		func() bool {
			position430, tokenIndex430 := position, tokenIndex
			{
				position431 := position
				if buffer[position] != rune('l') {
					goto l430
				}
				position++
				if buffer[position] != rune('i') {
					goto l430
				}
				position++
				if buffer[position] != rune('s') {
					goto l430
				}
				position++
				if buffer[position] != rune('t') {
					goto l430
				}
				position++
				if !_rules[rule_]() {
					goto l430
				}
				add(ruleLIST, position431)
			}
			return true
		l430:
			position, tokenIndex = position430, tokenIndex430
			return false
		},
		/* 82 EXISTS <- <('e' 'x' 'i' 's' 't' 's' _)> */
		func() bool {
			position432, tokenIndex432 := position, tokenIndex
			{
				position433 := position
				if buffer[position] != rune('e') {
					goto l432
				}
				position++
				if buffer[position] != rune('x') {
					goto l432
				}
				position++
				if buffer[position] != rune('i') {
					goto l432
				}
				position++
				if buffer[position] != rune('s') {
					goto l432
				}
				position++
				if buffer[position] != rune('t') {
					goto l432
				}
				position++
				if buffer[position] != rune('s') {
					goto l432
				}
				position++
				if !_rules[rule_]() {
					goto l432
				}
				add(ruleEXISTS, position433)
			}
			return true
		l432:
			position, tokenIndex = position432, tokenIndex432
			return false
		},
		/* 83 FREE <- <('f' 'r' 'e' 'e' _)> */
		func() bool {
			position434, tokenIndex434 := position, tokenIndex
			{
				position435 := position
				if buffer[position] != rune('f') {
					goto l434
				}
				position++
				if buffer[position] != rune('r') {
					goto l434
				}
				position++
				if buffer[position] != rune('e') {
					goto l434
				}
				position++
				if buffer[position] != rune('e') {
					goto l434
				}
				position++
				if !_rules[rule_]() {
					goto l434
				}
				add(ruleFREE, position435)
			}
			return true
		l434:
			position, tokenIndex = position434, tokenIndex434
			return false
		},
		/* 84 NEST <- <('n' 'e' 's' 't' _)> */
		func() bool {
			position436, tokenIndex436 := position, tokenIndex
			{
				position437 := position
				if buffer[position] != rune('n') {
					goto l436
				}
				position++
				if buffer[position] != rune('e') {
					goto l436
				}
				position++
				if buffer[position] != rune('s') {
					goto l436
				}
				position++
				if buffer[position] != rune('t') {
					goto l436
				}
				position++
				if !_rules[rule_]() {
					goto l436
				}
				add(ruleNEST, position437)
			}
			return true
		l436:
			position, tokenIndex = position436, tokenIndex436
			return false
		},
		/* 85 TRUE <- <('t' 'r' 'u' 'e' _)> */
		nil,
		/* 86 FALSE <- <('f' 'a' 'l' 's' 'e' _)> */
		nil,
		/* 87 EXTERNAL <- <('e' 'x' 't' 'e' 'r' 'n' 'a' 'l')> */
		func() bool {
			position440, tokenIndex440 := position, tokenIndex
			{
				position441 := position
				if buffer[position] != rune('e') {
					goto l440
				}
				position++
				if buffer[position] != rune('x') {
					goto l440
				}
				position++
				if buffer[position] != rune('t') {
					goto l440
				}
				position++
				if buffer[position] != rune('e') {
					goto l440
				}
				position++
				if buffer[position] != rune('r') {
					goto l440
				}
				position++
				if buffer[position] != rune('n') {
					goto l440
				}
				position++
				if buffer[position] != rune('a') {
					goto l440
				}
				position++
				if buffer[position] != rune('l') {
					goto l440
				}
				position++
				add(ruleEXTERNAL, position441)
			}
			return true
		l440:
			position, tokenIndex = position440, tokenIndex440
			return false
		},
		/* 88 NAME <- <('n' 'a' 'm' 'e')> */
		func() bool {
			position442, tokenIndex442 := position, tokenIndex
			{
				position443 := position
				if buffer[position] != rune('n') {
					goto l442
				}
				position++
				if buffer[position] != rune('a') {
					goto l442
				}
				position++
				if buffer[position] != rune('m') {
					goto l442
				}
				position++
				if buffer[position] != rune('e') {
					goto l442
				}
				position++
				add(ruleNAME, position443)
			}
			return true
		l442:
			position, tokenIndex = position442, tokenIndex442
			return false
		},
		/* 89 TYPE <- <('t' 'y' 'p' 'e')> */
		func() bool {
			position444, tokenIndex444 := position, tokenIndex
			{
				position445 := position
				if buffer[position] != rune('t') {
					goto l444
				}
				position++
				if buffer[position] != rune('y') {
					goto l444
				}
				position++
				if buffer[position] != rune('p') {
					goto l444
				}
				position++
				if buffer[position] != rune('e') {
					goto l444
				}
				position++
				add(ruleTYPE, position445)
			}
			return true
		l444:
			position, tokenIndex = position444, tokenIndex444
			return false
		},
		/* 90 VERB <- <('v' 'e' 'r' 'b')> */
		func() bool {
			position446, tokenIndex446 := position, tokenIndex
			{
				position447 := position
				if buffer[position] != rune('v') {
					goto l446
				}
				position++
				if buffer[position] != rune('e') {
					goto l446
				}
				position++
				if buffer[position] != rune('r') {
					goto l446
				}
				position++
				if buffer[position] != rune('b') {
					goto l446
				}
				position++
				add(ruleVERB, position447)
			}
			return true
		l446:
			position, tokenIndex = position446, tokenIndex446
			return false
		},
		/* 91 MECHANISM <- <('m' 'e' 'c' 'h' 'a' 'n' 'i' 's' 'm')> */
		func() bool {
			position448, tokenIndex448 := position, tokenIndex
			{
				position449 := position
				if buffer[position] != rune('m') {
					goto l448
				}
				position++
				if buffer[position] != rune('e') {
					goto l448
				}
				position++
				if buffer[position] != rune('c') {
					goto l448
				}
				position++
				if buffer[position] != rune('h') {
					goto l448
				}
				position++
				if buffer[position] != rune('a') {
					goto l448
				}
				position++
				if buffer[position] != rune('n') {
					goto l448
				}
				position++
				if buffer[position] != rune('i') {
					goto l448
				}
				position++
				if buffer[position] != rune('s') {
					goto l448
				}
				position++
				if buffer[position] != rune('m') {
					goto l448
				}
				position++
				add(ruleMECHANISM, position449)
			}
			return true
		l448:
			position, tokenIndex = position448, tokenIndex448
			return false
		},
		/* 92 ASYNC <- <('a' 's' 'y' 'n' 'c')> */
		func() bool {
			position450, tokenIndex450 := position, tokenIndex
			{
				position451 := position
				if buffer[position] != rune('a') {
					goto l450
				}
				position++
				if buffer[position] != rune('s') {
					goto l450
				}
				position++
				if buffer[position] != rune('y') {
					goto l450
				}
				position++
				if buffer[position] != rune('n') {
					goto l450
				}
				position++
				if buffer[position] != rune('c') {
					goto l450
				}
				position++
				add(ruleASYNC, position451)
			}
			return true
		l450:
			position, tokenIndex = position450, tokenIndex450
			return false
		},
		/* 93 EXPANDED <- <('e' 'x' 'p' 'a' 'n' 'd' 'e' 'd')> */
		func() bool {
			position452, tokenIndex452 := position, tokenIndex
			{
				position453 := position
				if buffer[position] != rune('e') {
					goto l452
				}
				position++
				if buffer[position] != rune('x') {
					goto l452
				}
				position++
				if buffer[position] != rune('p') {
					goto l452
				}
				position++
				if buffer[position] != rune('a') {
					goto l452
				}
				position++
				if buffer[position] != rune('n') {
					goto l452
				}
				position++
				if buffer[position] != rune('d') {
					goto l452
				}
				position++
				if buffer[position] != rune('e') {
					goto l452
				}
				position++
				if buffer[position] != rune('d') {
					goto l452
				}
				position++
				add(ruleEXPANDED, position453)
			}
			return true
		l452:
			position, tokenIndex = position452, tokenIndex452
			return false
		},
		/* 94 PERSON <- <('p' 'e' 'r' 's' 'o' 'n' _)> */
		nil,
		/* 95 DATABASE <- <('d' 'a' 't' 'a' 'b' 'a' 's' 'e' _)> */
		nil,
		/* 96 QUEUE <- <('q' 'u' 'e' 'u' 'e' _)> */
		nil,
		/* 97 BLOBSTORE <- <('b' 'l' 'o' 'b' 's' 't' 'o' 'r' 'e' _)> */
		nil,
		/* 98 BROWSER <- <('b' 'r' 'o' 'w' 's' 'e' 'r' _)> */
		nil,
		/* 99 MOBILE <- <('m' 'o' 'b' 'i' 'l' 'e' _)> */
		nil,
		/* 100 SERVER <- <('s' 'e' 'r' 'v' 'e' 'r' _)> */
		nil,
		/* 101 DEVICE <- <('d' 'e' 'v' 'i' 'c' 'e' _)> */
		nil,
		/* 102 CODE <- <('c' 'o' 'd' 'e' _)> */
		nil,
		/* 103 DELIMITER <- <('$' '$')> */
		func() bool {
			position463, tokenIndex463 := position, tokenIndex
			{
				position464 := position
				if buffer[position] != rune('$') {
					goto l463
				}
				position++
				if buffer[position] != rune('$') {
					goto l463
				}
				position++
				add(ruleDELIMITER, position464)
			}
			return true
		l463:
			position, tokenIndex = position463, tokenIndex463
			return false
		},
		/* 104 QUOTE <- <'"'> */
		func() bool {
			position465, tokenIndex465 := position, tokenIndex
			{
				position466 := position
				if buffer[position] != rune('"') {
					goto l465
				}
				position++
				add(ruleQUOTE, position466)
			}
			return true
		l465:
			position, tokenIndex = position465, tokenIndex465
			return false
		},
		/* 105 EQUALS <- <'='> */
		func() bool {
			position467, tokenIndex467 := position, tokenIndex
			{
				position468 := position
				if buffer[position] != rune('=') {
					goto l467
				}
				position++
				add(ruleEQUALS, position468)
			}
			return true
		l467:
			position, tokenIndex = position467, tokenIndex467
			return false
		},
		/* 106 FLAG <- <('-' '-'?)> */
		func() bool {
			position469, tokenIndex469 := position, tokenIndex
			{
				position470 := position
				if buffer[position] != rune('-') {
					goto l469
				}
				position++
				{
					position471, tokenIndex471 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l471
					}
					position++
					goto l472
				l471:
					position, tokenIndex = position471, tokenIndex471
				}
			l472:
				add(ruleFLAG, position470)
			}
			return true
		l469:
			position, tokenIndex = position469, tokenIndex469
			return false
		},
		/* 107 STRICT <- <('s' 't' 'r' 'i' 'c' 't' _)> */
		nil,
		/* 108 VERBOSE <- <('v' 'e' 'r' 'b' 'o' 's' 'e' _)> */
		nil,
		/* 109 IDS <- <('i' 'd' 's' _)> */
		nil,
		/* 110 _ <- <Whitespace*> */
		func() bool {
			{
				position477 := position
			l478:
				{
					position479, tokenIndex479 := position, tokenIndex
					{
						position480 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l479
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l479
								}
								position++
							default:
								{
									position482 := position
									{
										position483, tokenIndex483 := position, tokenIndex
										if buffer[position] != rune('\r') {
											goto l484
										}
										position++
										if buffer[position] != rune('\n') {
											goto l484
										}
										position++
										goto l483
									l484:
										position, tokenIndex = position483, tokenIndex483
										if buffer[position] != rune('\n') {
											goto l485
										}
										position++
										goto l483
									l485:
										position, tokenIndex = position483, tokenIndex483
										if buffer[position] != rune('\r') {
											goto l479
										}
										position++
									}
								l483:
									add(ruleEOL, position482)
								}
							}
						}

						add(ruleWhitespace, position480)
					}
					goto l478
				l479:
					position, tokenIndex = position479, tokenIndex479
				}
				add(rule_, position477)
			}
			return true
		},
		/* 111 Whitespace <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EOL))> */
		nil,
		/* 112 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		nil,
		/* 113 END <- <!.> */
		func() bool {
			position488, tokenIndex488 := position, tokenIndex
			{
				position489 := position
				{
					position490, tokenIndex490 := position, tokenIndex
					if !matchDot() {
						goto l490
					}
					goto l488
				l490:
					position, tokenIndex = position490, tokenIndex490
				}
				add(ruleEND, position489)
			}
			return true
		l488:
			position, tokenIndex = position488, tokenIndex488
			return false
		},
		/* 115 Action0 <- <{
		   p.StmtType = "Response"
		 }> */
		nil,
		/* 116 Action1 <- <{
		   p.StmtType = "Command"
		   p.InputAttributes.Raw = p.Buffer
		 }> */
		nil,
		nil,
		/* 118 Action2 <- <{ p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text)) }> */
		nil,
		/* 119 Action3 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 120 Action4 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 121 Action5 <- <{ p.InputAttributes.Verb = "create-or-fetch" }> */
		nil,
		/* 122 Action6 <- <{ p.InputAttributes.Verb = "create-or-set" }> */
		nil,
		/* 123 Action7 <- <{ p.Response.Object.Type = "world"; p.Response.Object.Repr = strings.Join(append([]string{p.treeString}, p.relStrings...), "\n") }> */
		nil,
		/* 124 Action8 <- <{ p.Response.Object.Type = "item"; p.Response.Object.Repr = cleanString(text); p.itemStrings = append(p.itemStrings, strings.TrimSpace(text)) }> */
		nil,
		/* 125 Action9 <- <{ p.Response.Object.Type = "rel"; p.Response.Object.Repr = cleanString(text); p.relStrings = append(p.relStrings, strings.TrimSpace(text)) }> */
		nil,
		/* 126 Action10 <- <{ p.Response.Object.Type = "ids"; b, _ := json.Marshal(p.InputAttributes.ResourceIds); p.Response.Object.Repr = string(b) }> */
		nil,
		/* 127 Action11 <- <{
		   p.Response.Object.Type = "tree"; p.Response.Object.Repr = text
		   p.treeString = text
		 }> */
		nil,
		/* 128 Action12 <- <{
		   p.Response.Status.Message = cleanString(text)
		 }> */
		nil,
		/* 129 Action13 <- <{ p.Response.Status.Code = p.number }> */
		nil,
		/* 130 Action14 <- <{ p.InputAttributes.Params["limit"] = cleanString(text) }> */
		nil,
		/* 131 Action15 <- <{ p.InputAttributes.ResourceId = cleanString(text) }> */
		nil,
		/* 132 Action16 <- <{
		   p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		 }> */
		nil,
		/* 133 Action17 <- <{
		   p.InputAttributes.ResourceId = ""
		   ids := strings.Fields(text)
		   for _, id := range ids {
		     p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
		   }
		 }> */
		nil,
		/* 134 Action18 <- <{ p.Params["external"] = cleanString(text) }> */
		nil,
		/* 135 Action19 <- <{ p.Params["type"] = cleanString(text) }> */
		nil,
		/* 136 Action20 <- <{ p.Params["name"] = cleanString(text) }> */
		nil,
		/* 137 Action21 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 138 Action22 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 139 Action23 <- <{ p.Params["verb"] = cleanString(text) }> */
		nil,
		/* 140 Action24 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 141 Action25 <- <{ p.Params["async"] = cleanString(text) }> */
		nil,
		/* 142 Action26 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 143 Action27 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 144 Action28 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 145 Action29 <- <{ p.text = cleanString(text) }> */
		nil,
		/* 146 Action30 <- <{ n, _ := strconv.Atoi(text); p.number = n }> */
		nil,
		/* 147 Action31 <- <{ p.bool = text == "true" }> */
		nil,
		/* 148 Action32 <- <{ p.InputAttributes.ResourceType = "item"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 149 Action33 <- <{ p.InputAttributes.ResourceType = "rel"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 150 Action34 <- <{ p.InputAttributes.ResourceType = "world" }> */
		nil,
		/* 151 Action35 <- <{ p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 152 Action36 <- <{ p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 153 Action37 <- <{ p.InputAttributes.Verb = "create" }> */
		nil,
		/* 154 Action38 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 155 Action39 <- <{ p.InputAttributes.Verb = "set" }> */
		nil,
		/* 156 Action40 <- <{ p.InputAttributes.Verb = "clear" }> */
		nil,
		/* 157 Action41 <- <{ p.InputAttributes.Verb = "delete" }> */
		nil,
		/* 158 Action42 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 159 Action43 <- <{ p.InputAttributes.Verb = "nest"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 160 Action44 <- <{ p.InputAttributes.Verb = "free"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 161 Action45 <- <{ p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 162 Action46 <- <{ p.InputAttributes.Verb = "in?"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 163 Action47 <- <{ p.InputAttributes.Verb = "from?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 164 Action48 <- <{ p.InputAttributes.Verb = "to?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 165 Action49 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict") }> */
		nil,
		/* 166 Action50 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose") }> */
		nil,
		/* 167 Action51 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids") }> */
		nil,
	}
	p.rules = _rules
	return nil
}
