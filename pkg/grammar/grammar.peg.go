package grammar

// Code generated by peg -inline -switch -strict -output pkg/grammar/grammar.peg.go pkg/grammar/grammar.peg DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleValid
	ruleResponse
	ruleCommand
	ruleMutation
	ruleTreeMutation
	ruleQuery
	ruleFetchQuery
	ruleListQuery
	ruleExistsQuery
	ruleStateBound
	ruleCreateOrFetch
	ruleCreateOrSet
	ruleObjects
	ruleWorldObject
	ruleItemObject
	ruleRelObject
	ruleIdentifierListObject
	ruleTree
	ruleNil
	ruleStatusObject
	ruleErrCode
	ruleLimit
	ruleIdentifier
	ruleSecondIdentifier
	ruleDualIdentifier
	ruleIdentifierList
	ruleWorldParams
	ruleItemParams
	ruleRelParams
	ruleWorldParamVersion
	ruleWorldParamId
	ruleWorldParamName
	ruleWorldParamExpanded
	ruleItemParam
	ruleRelParam
	ruleItemKeys
	ruleRelKeys
	ruleItemKey
	ruleRelKey
	ruleStringLike
	ruleNumber
	ruleBoolean
	ruleText
	ruleQuotedText
	ruleItemExists
	ruleRelExists
	ruleWorld
	ruleItem
	ruleRel
	ruleCreate
	ruleFetch
	ruleSet
	ruleClear
	ruleDelete
	ruleList
	ruleNest
	ruleFree
	ruleExists
	ruleInQuery
	ruleFromQuery
	ruleToQuery
	ruleFlag
	ruleStrictFlag
	ruleVerboseFlag
	ruleIdsFlag
	ruleBeginWorld
	ruleEndWorld
	ruleItemType
	ruleKeyword
	ruleWORLD
	ruleENDWORLD
	ruleERROR
	ruleOK
	ruleITEM
	ruleITEM_EXISTS
	ruleREL
	ruleREL_EXISTS
	ruleFROM_QUERY
	ruleTO_QUERY
	ruleIN
	ruleIN_QUERY
	ruleCREATE
	ruleDELETE
	ruleSET
	ruleCLEAR
	ruleFETCH
	ruleLIST
	ruleEXISTS
	ruleFREE
	ruleNEST
	ruleTRUE
	ruleFALSE
	ruleEXTERNAL
	ruleNAME
	ruleTYPE
	ruleVERB
	ruleMECHANISM
	ruleASYNC
	ruleEXPANDED
	ruleVERSION
	ruleID
	rulePERSON
	ruleDATABASE
	ruleQUEUE
	ruleBLOBSTORE
	ruleBROWSER
	ruleMOBILE
	ruleSERVER
	ruleDEVICE
	ruleCODE
	ruleDELIMITER
	ruleQUOTE
	ruleEQUALS
	ruleFLAG
	ruleSTRICT
	ruleVERBOSE
	ruleIDS
	rule_
	ruleWhitespace
	ruleEOL
	ruleEND
	ruleAction0
	ruleAction1
	rulePegText
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
)

var rul3s = [...]string{
	"Unknown",
	"Valid",
	"Response",
	"Command",
	"Mutation",
	"TreeMutation",
	"Query",
	"FetchQuery",
	"ListQuery",
	"ExistsQuery",
	"StateBound",
	"CreateOrFetch",
	"CreateOrSet",
	"Objects",
	"WorldObject",
	"ItemObject",
	"RelObject",
	"IdentifierListObject",
	"Tree",
	"Nil",
	"StatusObject",
	"ErrCode",
	"Limit",
	"Identifier",
	"SecondIdentifier",
	"DualIdentifier",
	"IdentifierList",
	"WorldParams",
	"ItemParams",
	"RelParams",
	"WorldParamVersion",
	"WorldParamId",
	"WorldParamName",
	"WorldParamExpanded",
	"ItemParam",
	"RelParam",
	"ItemKeys",
	"RelKeys",
	"ItemKey",
	"RelKey",
	"StringLike",
	"Number",
	"Boolean",
	"Text",
	"QuotedText",
	"ItemExists",
	"RelExists",
	"World",
	"Item",
	"Rel",
	"Create",
	"Fetch",
	"Set",
	"Clear",
	"Delete",
	"List",
	"Nest",
	"Free",
	"Exists",
	"InQuery",
	"FromQuery",
	"ToQuery",
	"Flag",
	"StrictFlag",
	"VerboseFlag",
	"IdsFlag",
	"BeginWorld",
	"EndWorld",
	"ItemType",
	"Keyword",
	"WORLD",
	"ENDWORLD",
	"ERROR",
	"OK",
	"ITEM",
	"ITEM_EXISTS",
	"REL",
	"REL_EXISTS",
	"FROM_QUERY",
	"TO_QUERY",
	"IN",
	"IN_QUERY",
	"CREATE",
	"DELETE",
	"SET",
	"CLEAR",
	"FETCH",
	"LIST",
	"EXISTS",
	"FREE",
	"NEST",
	"TRUE",
	"FALSE",
	"EXTERNAL",
	"NAME",
	"TYPE",
	"VERB",
	"MECHANISM",
	"ASYNC",
	"EXPANDED",
	"VERSION",
	"ID",
	"PERSON",
	"DATABASE",
	"QUEUE",
	"BLOBSTORE",
	"BROWSER",
	"MOBILE",
	"SERVER",
	"DEVICE",
	"CODE",
	"DELIMITER",
	"QUOTE",
	"EQUALS",
	"FLAG",
	"STRICT",
	"VERBOSE",
	"IDS",
	"_",
	"Whitespace",
	"EOL",
	"END",
	"Action0",
	"Action1",
	"PegText",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	StmtType string
	InputAttributes
	Response

	text   string // Text parsed by the StringLike rule.
	number int    // Number parsed by the Number rule.
	bool   bool   // Boolean parsed by the Boolean rule.

	Tree        Node     // The root of the world.Tree.
	TreeString  string   // Track the string representation of the Tree parsed by the Tree rule.
	ItemStrings []string // Track the string representations of Items parsed by the ItemObject rule.
	RelStrings  []string // Track the string representations of Rels parsed by the RelObject rule.

	// For building the tree.
	currentId string // Current Identifier being parsed.
	nodeStack []Node // Stack of nodes for building the tree.

	// For parsing World.
	WorldParams map[string]string

	Buffer string
	buffer []rune
	rules  [181]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *Parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.StmtType = "Response"

		case ruleAction1:

			p.StmtType = "Command"
			p.InputAttributes.Raw = p.Buffer

		case ruleAction2:
			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		case ruleAction3:
			p.InputAttributes.Verb = "fetch"
		case ruleAction4:
			p.InputAttributes.Verb = "list"
		case ruleAction5:
			p.InputAttributes.Verb = "create-or-fetch"
		case ruleAction6:
			p.InputAttributes.Verb = "create-or-set"
		case ruleAction7:

			p.StmtType = "WorldObject"
			p.Response.Object.Type = "world"
			p.Response.Object.Repr = strings.Join(append([]string{p.WorldParams["paramString"], p.TreeString}, p.RelStrings...), "\n")

		case ruleAction8:

			p.Response.Object.Type = "item"
			p.Response.Object.Repr = strings.TrimSpace(text)
			p.ItemStrings = append(p.ItemStrings, strings.TrimSpace(text))
			p.currentId = p.InputAttributes.ResourceId
			p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})

		case ruleAction9:
			p.Response.Object.Type = "rel"
			p.Response.Object.Repr = strings.TrimSpace(text)
			p.RelStrings = append(p.RelStrings, strings.TrimSpace(text))
		case ruleAction10:
			p.Response.Object.Type = "ids"
			b, _ := json.Marshal(p.InputAttributes.ResourceIds)
			p.Response.Object.Repr = string(b)
		case ruleAction11:

			p.StmtType = "Tree"
			p.Response.Object.Type = "tree"
			p.Response.Object.Repr = text
			p.TreeString = text
			if len(p.nodeStack) > 0 {
				node := p.nodeStack[len(p.nodeStack)-1]
				p.nodeStack = p.nodeStack[:len(p.nodeStack)-1]
				if len(p.nodeStack) > 0 {
					p.nodeStack[len(p.nodeStack)-1].Children = append(p.nodeStack[len(p.nodeStack)-1].Children, node)
				} else {
					p.Tree = node
				}
			}

		case ruleAction12:

			p.currentId = "nil"
			p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})

		case ruleAction13:

			p.StmtType = "Status"
			p.Response.Status.Message = cleanString(text)

		case ruleAction14:
			p.Response.Status.Code = p.number
		case ruleAction15:
			p.InputAttributes.Params["limit"] = cleanString(text)
		case ruleAction16:
			p.InputAttributes.ResourceId = cleanString(text)
		case ruleAction17:

			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))

		case ruleAction18:

			p.InputAttributes.ResourceId = ""
			ids := strings.Fields(text)
			for _, id := range ids {
				p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
			}

		case ruleAction19:

			p.WorldParams["paramString"] = fmt.Sprintf("version=%s\nid=%s\nname=%s\nexpanded=%s", p.WorldParams["version"], p.WorldParams["id"], p.WorldParams["name"], p.WorldParams["expanded"])

		case ruleAction20:
			p.WorldParams["version"] = cleanString(text)
		case ruleAction21:
			p.WorldParams["id"] = cleanString(text)
		case ruleAction22:
			p.WorldParams["name"] = strings.TrimSpace(text)
		case ruleAction23:
			p.WorldParams["expanded"] = strings.TrimSpace(text)
		case ruleAction24:
			p.Params["external"] = cleanString(text)
		case ruleAction25:
			p.Params["type"] = cleanString(text)
		case ruleAction26:
			p.Params["name"] = cleanString(text)
		case ruleAction27:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction28:
			p.Params["expanded"] = cleanString(text)
		case ruleAction29:
			p.Params["verb"] = cleanString(text)
		case ruleAction30:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction31:
			p.Params["async"] = cleanString(text)
		case ruleAction32:
			p.Params["expanded"] = cleanString(text)
		case ruleAction33:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction34:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction35:
			p.text = cleanString(text)
		case ruleAction36:
			n, _ := strconv.Atoi(text)
			p.number = n
		case ruleAction37:
			p.bool = text == "true"
		case ruleAction38:
			p.InputAttributes.ResourceType = "item"
			p.InputAttributes.Verb = "exists"
		case ruleAction39:
			p.InputAttributes.ResourceType = "rel"
			p.InputAttributes.Verb = "exists"
		case ruleAction40:
			p.InputAttributes.ResourceType = "world"
		case ruleAction41:
			p.InputAttributes.ResourceType = "item"
		case ruleAction42:
			p.InputAttributes.ResourceType = "rel"
		case ruleAction43:
			p.InputAttributes.Verb = "create"
		case ruleAction44:
			p.InputAttributes.Verb = "fetch"
		case ruleAction45:
			p.InputAttributes.Verb = "set"
		case ruleAction46:
			p.InputAttributes.Verb = "clear"
		case ruleAction47:
			p.InputAttributes.Verb = "delete"
		case ruleAction48:
			p.InputAttributes.Verb = "list"
		case ruleAction49:
			p.InputAttributes.Verb = "nest"
			p.InputAttributes.ResourceType = "item"
		case ruleAction50:
			p.InputAttributes.Verb = "free"
			p.InputAttributes.ResourceType = "item"
		case ruleAction51:
			p.InputAttributes.Verb = "exists"
		case ruleAction52:
			p.InputAttributes.Verb = "in?"
			p.InputAttributes.ResourceType = "item"
		case ruleAction53:
			p.InputAttributes.Verb = "from?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction54:
			p.InputAttributes.Verb = "to?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction55:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict")
		case ruleAction56:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose")
		case ruleAction57:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids")

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Valid <- <(Command / Response / ((&('t') Tree) | (&('\t' | '\n' | '\r' | ' ' | '$') WorldObject) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') StatusObject)))> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if !_rules[rule_]() {
							goto l3
						}
						{
							position5, tokenIndex5 := position, tokenIndex
							{
								position7 := position
								{
									position8, tokenIndex8 := position, tokenIndex
									if !_rules[ruleItem]() {
										goto l9
									}
									{
										position10, tokenIndex10 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l11
										}
										goto l10
									l11:
										position, tokenIndex = position10, tokenIndex10
										if !_rules[ruleSet]() {
											goto l9
										}
									}
								l10:
									if !_rules[ruleIdentifier]() {
										goto l9
									}
									{
										position12, tokenIndex12 := position, tokenIndex
										if !_rules[ruleItemParams]() {
											goto l12
										}
										goto l13
									l12:
										position, tokenIndex = position12, tokenIndex12
									}
								l13:
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l14
									}
									if !_rules[ruleClear]() {
										goto l14
									}
									if !_rules[ruleIdentifier]() {
										goto l14
									}
									{
										position15 := position
										{
											position18 := position
											{
												position19 := position
												{
													position20, tokenIndex20 := position, tokenIndex
													if !_rules[ruleEXTERNAL]() {
														goto l21
													}
													goto l20
												l21:
													position, tokenIndex = position20, tokenIndex20
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l14
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l14
															}
														case 't':
															if !_rules[ruleTYPE]() {
																goto l14
															}
														default:
															if !_rules[ruleNAME]() {
																goto l14
															}
														}
													}

												}
											l20:
												add(rulePegText, position19)
											}
											if !_rules[rule_]() {
												goto l14
											}
											{
												add(ruleAction33, position)
											}
											add(ruleItemKey, position18)
										}
									l16:
										{
											position17, tokenIndex17 := position, tokenIndex
											{
												position24 := position
												{
													position25 := position
													{
														position26, tokenIndex26 := position, tokenIndex
														if !_rules[ruleEXTERNAL]() {
															goto l27
														}
														goto l26
													l27:
														position, tokenIndex = position26, tokenIndex26
														{
															switch buffer[position] {
															case 'e':
																if !_rules[ruleEXPANDED]() {
																	goto l17
																}
															case 'm':
																if !_rules[ruleMECHANISM]() {
																	goto l17
																}
															case 't':
																if !_rules[ruleTYPE]() {
																	goto l17
																}
															default:
																if !_rules[ruleNAME]() {
																	goto l17
																}
															}
														}

													}
												l26:
													add(rulePegText, position25)
												}
												if !_rules[rule_]() {
													goto l17
												}
												{
													add(ruleAction33, position)
												}
												add(ruleItemKey, position24)
											}
											goto l16
										l17:
											position, tokenIndex = position17, tokenIndex17
										}
										add(ruleItemKeys, position15)
									}
									goto l8
								l14:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l30
									}
									if !_rules[ruleDelete]() {
										goto l30
									}
									if !_rules[ruleIdentifier]() {
										goto l30
									}
									goto l8
								l30:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l31
									}
									{
										position32, tokenIndex32 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l33
										}
										goto l32
									l33:
										position, tokenIndex = position32, tokenIndex32
										if !_rules[ruleSet]() {
											goto l31
										}
									}
								l32:
									if !_rules[ruleDualIdentifier]() {
										goto l31
									}
									{
										position34, tokenIndex34 := position, tokenIndex
										if !_rules[ruleRelParams]() {
											goto l34
										}
										goto l35
									l34:
										position, tokenIndex = position34, tokenIndex34
									}
								l35:
									goto l8
								l31:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l36
									}
									if !_rules[ruleClear]() {
										goto l36
									}
									if !_rules[ruleDualIdentifier]() {
										goto l36
									}
									{
										position37 := position
										{
											position40 := position
											{
												position41 := position
												{
													switch buffer[position] {
													case 'e':
														if !_rules[ruleEXPANDED]() {
															goto l36
														}
													case 'a':
														if !_rules[ruleASYNC]() {
															goto l36
														}
													case 'm':
														if !_rules[ruleMECHANISM]() {
															goto l36
														}
													default:
														if !_rules[ruleVERB]() {
															goto l36
														}
													}
												}

												add(rulePegText, position41)
											}
											if !_rules[rule_]() {
												goto l36
											}
											{
												add(ruleAction34, position)
											}
											add(ruleRelKey, position40)
										}
									l38:
										{
											position39, tokenIndex39 := position, tokenIndex
											{
												position44 := position
												{
													position45 := position
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l39
															}
														case 'a':
															if !_rules[ruleASYNC]() {
																goto l39
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l39
															}
														default:
															if !_rules[ruleVERB]() {
																goto l39
															}
														}
													}

													add(rulePegText, position45)
												}
												if !_rules[rule_]() {
													goto l39
												}
												{
													add(ruleAction34, position)
												}
												add(ruleRelKey, position44)
											}
											goto l38
										l39:
											position, tokenIndex = position39, tokenIndex39
										}
										add(ruleRelKeys, position37)
									}
									goto l8
								l36:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l6
									}
									if !_rules[ruleDelete]() {
										goto l6
									}
									if !_rules[ruleDualIdentifier]() {
										goto l6
									}
								}
							l8:
								add(ruleMutation, position7)
							}
							goto l5
						l6:
							position, tokenIndex = position5, tokenIndex5
							{
								position49 := position
								{
									position50, tokenIndex50 := position, tokenIndex
									{
										position52 := position
										if !_rules[ruleFREE]() {
											goto l51
										}
										{
											add(ruleAction50, position)
										}
										add(ruleFree, position52)
									}
									if !_rules[ruleIdentifierList]() {
										goto l51
									}
									goto l50
								l51:
									position, tokenIndex = position50, tokenIndex50
									{
										position54 := position
										if !_rules[ruleNEST]() {
											goto l48
										}
										{
											add(ruleAction49, position)
										}
										add(ruleNest, position54)
									}
									if !_rules[ruleIdentifierList]() {
										goto l48
									}
									if !_rules[rule_]() {
										goto l48
									}
									if !_rules[ruleIN]() {
										goto l48
									}
									{
										position56 := position
										if !_rules[ruleStringLike]() {
											goto l48
										}
										add(rulePegText, position56)
									}
									{
										add(ruleAction2, position)
									}
								}
							l50:
								add(ruleTreeMutation, position49)
							}
							goto l5
						l48:
							position, tokenIndex = position5, tokenIndex5
							{
								position59 := position
								{
									position60, tokenIndex60 := position, tokenIndex
									{
										position62 := position
										{
											switch buffer[position] {
											case 'w':
												{
													position64 := position
													if !_rules[ruleWORLD]() {
														goto l61
													}
													{
														add(ruleAction40, position)
													}
													add(ruleWorld, position64)
												}
												{
													add(ruleAction3, position)
												}
											case 'r':
												if !_rules[ruleRel]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleDualIdentifier]() {
													goto l61
												}
											default:
												if !_rules[ruleItem]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleIdentifier]() {
													goto l61
												}
											}
										}

										add(ruleFetchQuery, position62)
									}
									goto l60
								l61:
									position, tokenIndex = position60, tokenIndex60
									{
										position68 := position
										{
											position69, tokenIndex69 := position, tokenIndex
											{
												position71, tokenIndex71 := position, tokenIndex
												if !_rules[ruleItem]() {
													goto l72
												}
												goto l71
											l72:
												position, tokenIndex = position71, tokenIndex71
												if !_rules[ruleRel]() {
													goto l70
												}
											}
										l71:
											{
												position73 := position
												if !_rules[ruleLIST]() {
													goto l70
												}
												{
													add(ruleAction48, position)
												}
												add(ruleList, position73)
											}
											{
												position75, tokenIndex75 := position, tokenIndex
												{
													position77 := position
													{
														position78 := position
														if !_rules[ruleNumber]() {
															goto l75
														}
														add(rulePegText, position78)
													}
													{
														add(ruleAction15, position)
													}
													add(ruleLimit, position77)
												}
												goto l76
											l75:
												position, tokenIndex = position75, tokenIndex75
											}
										l76:
											goto l69
										l70:
											position, tokenIndex = position69, tokenIndex69
											{
												switch buffer[position] {
												case 'f':
													{
														position81 := position
														if !_rules[ruleFROM_QUERY]() {
															goto l67
														}
														{
															add(ruleAction53, position)
														}
														add(ruleFromQuery, position81)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												case 't':
													{
														position83 := position
														if !_rules[ruleTO_QUERY]() {
															goto l67
														}
														{
															add(ruleAction54, position)
														}
														add(ruleToQuery, position83)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												default:
													if !_rules[ruleItem]() {
														goto l67
													}
													if !_rules[ruleIN]() {
														goto l67
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
													{
														add(ruleAction4, position)
													}
												}
											}

										}
									l69:
										add(ruleListQuery, position68)
									}
									goto l60
								l67:
									position, tokenIndex = position60, tokenIndex60
									{
										position86 := position
										{
											position87, tokenIndex87 := position, tokenIndex
											{
												position89 := position
												if !_rules[ruleIN_QUERY]() {
													goto l88
												}
												{
													add(ruleAction52, position)
												}
												add(ruleInQuery, position89)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l88
											}
											goto l87
										l88:
											position, tokenIndex = position87, tokenIndex87
											{
												position92 := position
												{
													position93, tokenIndex93 := position, tokenIndex
													if !_rules[ruleITEM_EXISTS]() {
														goto l94
													}
													goto l93
												l94:
													position, tokenIndex = position93, tokenIndex93
													if !_rules[ruleItem]() {
														goto l91
													}
													if !_rules[ruleExists]() {
														goto l91
													}
												}
											l93:
												{
													add(ruleAction38, position)
												}
												add(ruleItemExists, position92)
											}
											if !_rules[ruleIdentifier]() {
												goto l91
											}
											goto l87
										l91:
											position, tokenIndex = position87, tokenIndex87
											{
												position96 := position
												{
													position97, tokenIndex97 := position, tokenIndex
													if !_rules[ruleREL_EXISTS]() {
														goto l98
													}
													goto l97
												l98:
													position, tokenIndex = position97, tokenIndex97
													if !_rules[ruleRel]() {
														goto l58
													}
													if !_rules[ruleExists]() {
														goto l58
													}
												}
											l97:
												{
													add(ruleAction39, position)
												}
												add(ruleRelExists, position96)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l58
											}
										}
									l87:
										add(ruleExistsQuery, position86)
									}
								}
							l60:
								add(ruleQuery, position59)
							}
							goto l5
						l58:
							position, tokenIndex = position5, tokenIndex5
							{
								position100 := position
								{
									position101, tokenIndex101 := position, tokenIndex
									{
										position103 := position
										{
											position104, tokenIndex104 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l105
											}
											if !_rules[ruleIdentifier]() {
												goto l105
											}
											{
												position106, tokenIndex106 := position, tokenIndex
												if !_rules[ruleItemParams]() {
													goto l106
												}
												goto l105
											l106:
												position, tokenIndex = position106, tokenIndex106
											}
											goto l104
										l105:
											position, tokenIndex = position104, tokenIndex104
											if !_rules[ruleRel]() {
												goto l102
											}
											if !_rules[ruleDualIdentifier]() {
												goto l102
											}
											{
												position107, tokenIndex107 := position, tokenIndex
												if !_rules[ruleRelParams]() {
													goto l107
												}
												goto l102
											l107:
												position, tokenIndex = position107, tokenIndex107
											}
										}
									l104:
										add(ruleCreateOrFetch, position103)
									}
									{
										add(ruleAction5, position)
									}
									goto l101
								l102:
									position, tokenIndex = position101, tokenIndex101
									{
										position109 := position
										{
											position110, tokenIndex110 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l111
											}
											if !_rules[ruleIdentifier]() {
												goto l111
											}
											if !_rules[ruleItemParams]() {
												goto l111
											}
											goto l110
										l111:
											position, tokenIndex = position110, tokenIndex110
											if !_rules[ruleRel]() {
												goto l3
											}
											if !_rules[ruleDualIdentifier]() {
												goto l3
											}
											if !_rules[ruleRelParams]() {
												goto l3
											}
										}
									l110:
										add(ruleCreateOrSet, position109)
									}
									{
										add(ruleAction6, position)
									}
								}
							l101:
								add(ruleStateBound, position100)
							}
						}
					l5:
					l113:
						{
							position114, tokenIndex114 := position, tokenIndex
							{
								position115 := position
								{
									position116, tokenIndex116 := position, tokenIndex
									{
										position118 := position
										if !_rules[ruleFLAG]() {
											goto l117
										}
										{
											position119 := position
											if buffer[position] != rune('s') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if buffer[position] != rune('r') {
												goto l117
											}
											position++
											if buffer[position] != rune('i') {
												goto l117
											}
											position++
											if buffer[position] != rune('c') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if !_rules[rule_]() {
												goto l117
											}
											add(ruleSTRICT, position119)
										}
										{
											add(ruleAction55, position)
										}
										add(ruleStrictFlag, position118)
									}
									goto l116
								l117:
									position, tokenIndex = position116, tokenIndex116
									{
										position122 := position
										if !_rules[ruleFLAG]() {
											goto l121
										}
										{
											position123 := position
											if buffer[position] != rune('v') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if buffer[position] != rune('r') {
												goto l121
											}
											position++
											if buffer[position] != rune('b') {
												goto l121
											}
											position++
											if buffer[position] != rune('o') {
												goto l121
											}
											position++
											if buffer[position] != rune('s') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if !_rules[rule_]() {
												goto l121
											}
											add(ruleVERBOSE, position123)
										}
										{
											add(ruleAction56, position)
										}
										add(ruleVerboseFlag, position122)
									}
									goto l116
								l121:
									position, tokenIndex = position116, tokenIndex116
									{
										position125 := position
										if !_rules[ruleFLAG]() {
											goto l114
										}
										{
											position126 := position
											if buffer[position] != rune('i') {
												goto l114
											}
											position++
											if buffer[position] != rune('d') {
												goto l114
											}
											position++
											if buffer[position] != rune('s') {
												goto l114
											}
											position++
											if !_rules[rule_]() {
												goto l114
											}
											add(ruleIDS, position126)
										}
										{
											add(ruleAction57, position)
										}
										add(ruleIdsFlag, position125)
									}
								}
							l116:
								add(ruleFlag, position115)
							}
							goto l113
						l114:
							position, tokenIndex = position114, tokenIndex114
						}
						if !_rules[ruleEND]() {
							goto l3
						}
						{
							add(ruleAction1, position)
						}
						add(ruleCommand, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position130 := position
						{
							position131, tokenIndex131 := position, tokenIndex
							{
								position133 := position
								{
									position134, tokenIndex134 := position, tokenIndex
									if !_rules[ruleWorldObject]() {
										goto l135
									}
									goto l134
								l135:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleTree]() {
										goto l136
									}
									goto l134
								l136:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleItemObject]() {
										goto l137
									}
								l138:
									{
										position139, tokenIndex139 := position, tokenIndex
										if !_rules[ruleItemObject]() {
											goto l139
										}
										goto l138
									l139:
										position, tokenIndex = position139, tokenIndex139
									}
									goto l134
								l137:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleRelObject]() {
										goto l140
									}
								l141:
									{
										position142, tokenIndex142 := position, tokenIndex
										if !_rules[ruleRelObject]() {
											goto l142
										}
										goto l141
									l142:
										position, tokenIndex = position142, tokenIndex142
									}
									goto l134
								l140:
									position, tokenIndex = position134, tokenIndex134
									{
										position143 := position
										if !_rules[ruleIdentifierList]() {
											goto l131
										}
										{
											add(ruleAction10, position)
										}
										add(ruleIdentifierListObject, position143)
									}
								}
							l134:
								add(ruleObjects, position133)
							}
							goto l132
						l131:
							position, tokenIndex = position131, tokenIndex131
						}
					l132:
						if !_rules[rule_]() {
							goto l129
						}
						if !_rules[ruleDELIMITER]() {
							goto l129
						}
						if !_rules[ruleDELIMITER]() {
							goto l129
						}
						if !_rules[rule_]() {
							goto l129
						}
						if !_rules[ruleStatusObject]() {
							goto l129
						}
						if !_rules[ruleEND]() {
							goto l129
						}
						{
							add(ruleAction0, position)
						}
						add(ruleResponse, position130)
					}
					goto l2
				l129:
					position, tokenIndex = position2, tokenIndex2
					{
						switch buffer[position] {
						case 't':
							if !_rules[ruleTree]() {
								goto l0
							}
						case '\t', '\n', '\r', ' ', '$':
							if !_rules[ruleWorldObject]() {
								goto l0
							}
						default:
							if !_rules[ruleStatusObject]() {
								goto l0
							}
						}
					}

				}
			l2:
				add(ruleValid, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Response <- <(Objects? _ DELIMITER DELIMITER _ StatusObject END Action0)> */
		nil,
		/* 2 Command <- <(_ (Mutation / TreeMutation / Query / StateBound) Flag* END Action1)> */
		nil,
		/* 3 Mutation <- <((Item (Create / Set) Identifier ItemParams?) / (Item Clear Identifier ItemKeys) / (Item Delete Identifier) / (Rel (Create / Set) DualIdentifier RelParams?) / (Rel Clear DualIdentifier RelKeys) / (Rel Delete DualIdentifier))> */
		nil,
		/* 4 TreeMutation <- <((Free IdentifierList) / (Nest IdentifierList _ IN <StringLike> Action2))> */
		nil,
		/* 5 Query <- <(FetchQuery / ListQuery / ExistsQuery)> */
		nil,
		/* 6 FetchQuery <- <((&('w') (World Action3)) | (&('r') (Rel Fetch DualIdentifier)) | (&('i') (Item Fetch Identifier)))> */
		nil,
		/* 7 ListQuery <- <(((Item / Rel) List Limit?) / ((&('f') (FromQuery Identifier)) | (&('t') (ToQuery Identifier)) | (&('i') (Item IN Identifier Action4))))> */
		nil,
		/* 8 ExistsQuery <- <((InQuery DualIdentifier) / (ItemExists Identifier) / (RelExists DualIdentifier))> */
		nil,
		/* 9 StateBound <- <((CreateOrFetch Action5) / (CreateOrSet Action6))> */
		nil,
		/* 10 CreateOrFetch <- <((Item Identifier !ItemParams) / (Rel DualIdentifier !RelParams))> */
		nil,
		/* 11 CreateOrSet <- <((Item Identifier ItemParams) / (Rel DualIdentifier RelParams))> */
		nil,
		/* 12 Objects <- <(WorldObject / Tree / ItemObject+ / RelObject+ / IdentifierListObject)> */
		nil,
		/* 13 WorldObject <- <(BeginWorld WorldParams Tree RelObject* EndWorld Action7)> */
		func() bool {
			position159, tokenIndex159 := position, tokenIndex
			{
				position160 := position
				{
					position161 := position
					if !_rules[rule_]() {
						goto l159
					}
					if !_rules[ruleDELIMITER]() {
						goto l159
					}
					if !_rules[ruleWORLD]() {
						goto l159
					}
					if !_rules[rule_]() {
						goto l159
					}
					add(ruleBeginWorld, position161)
				}
				{
					position162 := position
					if !_rules[rule_]() {
						goto l159
					}
					{
						position163 := position
						{
							position164 := position
							if buffer[position] != rune('v') {
								goto l159
							}
							position++
							if buffer[position] != rune('e') {
								goto l159
							}
							position++
							if buffer[position] != rune('r') {
								goto l159
							}
							position++
							if buffer[position] != rune('s') {
								goto l159
							}
							position++
							if buffer[position] != rune('i') {
								goto l159
							}
							position++
							if buffer[position] != rune('o') {
								goto l159
							}
							position++
							if buffer[position] != rune('n') {
								goto l159
							}
							position++
							add(ruleVERSION, position164)
						}
						if !_rules[ruleEQUALS]() {
							goto l159
						}
						{
							position165 := position
							if !_rules[ruleNumber]() {
								goto l159
							}
							add(rulePegText, position165)
						}
						{
							add(ruleAction20, position)
						}
						add(ruleWorldParamVersion, position163)
					}
					if !_rules[rule_]() {
						goto l159
					}
					{
						position167 := position
						{
							position168 := position
							if buffer[position] != rune('i') {
								goto l159
							}
							position++
							if buffer[position] != rune('d') {
								goto l159
							}
							position++
							add(ruleID, position168)
						}
						if !_rules[ruleEQUALS]() {
							goto l159
						}
						{
							position169 := position
							if !_rules[ruleStringLike]() {
								goto l159
							}
							add(rulePegText, position169)
						}
						{
							add(ruleAction21, position)
						}
						add(ruleWorldParamId, position167)
					}
					if !_rules[rule_]() {
						goto l159
					}
					{
						position171 := position
						if !_rules[ruleNAME]() {
							goto l159
						}
						if !_rules[ruleEQUALS]() {
							goto l159
						}
						{
							position172 := position
							{
								position173, tokenIndex173 := position, tokenIndex
								if !_rules[ruleStringLike]() {
									goto l173
								}
								goto l174
							l173:
								position, tokenIndex = position173, tokenIndex173
							}
						l174:
							add(rulePegText, position172)
						}
						{
							add(ruleAction22, position)
						}
						add(ruleWorldParamName, position171)
					}
					if !_rules[rule_]() {
						goto l159
					}
					{
						position176 := position
						if !_rules[ruleEXPANDED]() {
							goto l159
						}
						if !_rules[ruleEQUALS]() {
							goto l159
						}
						{
							position177 := position
							{
								position178, tokenIndex178 := position, tokenIndex
								if !_rules[ruleStringLike]() {
									goto l178
								}
								goto l179
							l178:
								position, tokenIndex = position178, tokenIndex178
							}
						l179:
							add(rulePegText, position177)
						}
						{
							add(ruleAction23, position)
						}
						add(ruleWorldParamExpanded, position176)
					}
					if !_rules[rule_]() {
						goto l159
					}
					{
						add(ruleAction19, position)
					}
					add(ruleWorldParams, position162)
				}
				if !_rules[ruleTree]() {
					goto l159
				}
			l182:
				{
					position183, tokenIndex183 := position, tokenIndex
					if !_rules[ruleRelObject]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position183, tokenIndex183
				}
				{
					position184 := position
					if !_rules[rule_]() {
						goto l159
					}
					if !_rules[ruleENDWORLD]() {
						goto l159
					}
					if !_rules[ruleDELIMITER]() {
						goto l159
					}
					if !_rules[rule_]() {
						goto l159
					}
					add(ruleEndWorld, position184)
				}
				{
					add(ruleAction7, position)
				}
				add(ruleWorldObject, position160)
			}
			return true
		l159:
			position, tokenIndex = position159, tokenIndex159
			return false
		},
		/* 14 ItemObject <- <(<(Item Identifier ItemParams?)> Action8)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188 := position
					if !_rules[ruleItem]() {
						goto l186
					}
					if !_rules[ruleIdentifier]() {
						goto l186
					}
					{
						position189, tokenIndex189 := position, tokenIndex
						if !_rules[ruleItemParams]() {
							goto l189
						}
						goto l190
					l189:
						position, tokenIndex = position189, tokenIndex189
					}
				l190:
					add(rulePegText, position188)
				}
				{
					add(ruleAction8, position)
				}
				add(ruleItemObject, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 15 RelObject <- <(<(Rel DualIdentifier RelParams?)> Action9)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194 := position
					if !_rules[ruleRel]() {
						goto l192
					}
					if !_rules[ruleDualIdentifier]() {
						goto l192
					}
					{
						position195, tokenIndex195 := position, tokenIndex
						if !_rules[ruleRelParams]() {
							goto l195
						}
						goto l196
					l195:
						position, tokenIndex = position195, tokenIndex195
					}
				l196:
					add(rulePegText, position194)
				}
				{
					add(ruleAction9, position)
				}
				add(ruleRelObject, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 16 IdentifierListObject <- <(IdentifierList Action10)> */
		nil,
		/* 17 Tree <- <(<('t' 'r' 'e' 'e' '{' (Nil / ItemObject) (':' ':' '[') Tree* (']' '}'))> _ Action11)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201 := position
					if buffer[position] != rune('t') {
						goto l199
					}
					position++
					if buffer[position] != rune('r') {
						goto l199
					}
					position++
					if buffer[position] != rune('e') {
						goto l199
					}
					position++
					if buffer[position] != rune('e') {
						goto l199
					}
					position++
					if buffer[position] != rune('{') {
						goto l199
					}
					position++
					{
						position202, tokenIndex202 := position, tokenIndex
						{
							position204 := position
							if buffer[position] != rune('n') {
								goto l203
							}
							position++
							if buffer[position] != rune('i') {
								goto l203
							}
							position++
							if buffer[position] != rune('l') {
								goto l203
							}
							position++
							{
								add(ruleAction12, position)
							}
							add(ruleNil, position204)
						}
						goto l202
					l203:
						position, tokenIndex = position202, tokenIndex202
						if !_rules[ruleItemObject]() {
							goto l199
						}
					}
				l202:
					if buffer[position] != rune(':') {
						goto l199
					}
					position++
					if buffer[position] != rune(':') {
						goto l199
					}
					position++
					if buffer[position] != rune('[') {
						goto l199
					}
					position++
				l206:
					{
						position207, tokenIndex207 := position, tokenIndex
						if !_rules[ruleTree]() {
							goto l207
						}
						goto l206
					l207:
						position, tokenIndex = position207, tokenIndex207
					}
					if buffer[position] != rune(']') {
						goto l199
					}
					position++
					if buffer[position] != rune('}') {
						goto l199
					}
					position++
					add(rulePegText, position201)
				}
				if !_rules[rule_]() {
					goto l199
				}
				{
					add(ruleAction11, position)
				}
				add(ruleTree, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 18 Nil <- <('n' 'i' 'l' Action12)> */
		nil,
		/* 19 StatusObject <- <(ErrCode (ERROR / OK) <StringLike*> Action13)> */
		func() bool {
			position210, tokenIndex210 := position, tokenIndex
			{
				position211 := position
				{
					position212 := position
					{
						position213 := position
						if !_rules[ruleNumber]() {
							goto l210
						}
						add(rulePegText, position213)
					}
					{
						add(ruleAction14, position)
					}
					add(ruleErrCode, position212)
				}
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[ruleERROR]() {
						goto l216
					}
					goto l215
				l216:
					position, tokenIndex = position215, tokenIndex215
					if !_rules[ruleOK]() {
						goto l210
					}
				}
			l215:
				{
					position217 := position
				l218:
					{
						position219, tokenIndex219 := position, tokenIndex
						if !_rules[ruleStringLike]() {
							goto l219
						}
						goto l218
					l219:
						position, tokenIndex = position219, tokenIndex219
					}
					add(rulePegText, position217)
				}
				{
					add(ruleAction13, position)
				}
				add(ruleStatusObject, position211)
			}
			return true
		l210:
			position, tokenIndex = position210, tokenIndex210
			return false
		},
		/* 20 ErrCode <- <(<Number> Action14)> */
		nil,
		/* 21 Limit <- <(<Number> Action15)> */
		nil,
		/* 22 Identifier <- <(!Keyword <StringLike> Action16)> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				{
					position225, tokenIndex225 := position, tokenIndex
					if !_rules[ruleKeyword]() {
						goto l225
					}
					goto l223
				l225:
					position, tokenIndex = position225, tokenIndex225
				}
				{
					position226 := position
					if !_rules[ruleStringLike]() {
						goto l223
					}
					add(rulePegText, position226)
				}
				{
					add(ruleAction16, position)
				}
				add(ruleIdentifier, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 23 SecondIdentifier <- <(!Keyword &Identifier <StringLike> Action17)> */
		nil,
		/* 24 DualIdentifier <- <(Identifier SecondIdentifier)> */
		func() bool {
			position229, tokenIndex229 := position, tokenIndex
			{
				position230 := position
				if !_rules[ruleIdentifier]() {
					goto l229
				}
				{
					position231 := position
					{
						position232, tokenIndex232 := position, tokenIndex
						if !_rules[ruleKeyword]() {
							goto l232
						}
						goto l229
					l232:
						position, tokenIndex = position232, tokenIndex232
					}
					{
						position233, tokenIndex233 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l229
						}
						position, tokenIndex = position233, tokenIndex233
					}
					{
						position234 := position
						if !_rules[ruleStringLike]() {
							goto l229
						}
						add(rulePegText, position234)
					}
					{
						add(ruleAction17, position)
					}
					add(ruleSecondIdentifier, position231)
				}
				add(ruleDualIdentifier, position230)
			}
			return true
		l229:
			position, tokenIndex = position229, tokenIndex229
			return false
		},
		/* 25 IdentifierList <- <(<(Identifier Identifier*)> Action18)> */
		func() bool {
			position236, tokenIndex236 := position, tokenIndex
			{
				position237 := position
				{
					position238 := position
					if !_rules[ruleIdentifier]() {
						goto l236
					}
				l239:
					{
						position240, tokenIndex240 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l240
						}
						goto l239
					l240:
						position, tokenIndex = position240, tokenIndex240
					}
					add(rulePegText, position238)
				}
				{
					add(ruleAction18, position)
				}
				add(ruleIdentifierList, position237)
			}
			return true
		l236:
			position, tokenIndex = position236, tokenIndex236
			return false
		},
		/* 26 WorldParams <- <(_ WorldParamVersion _ WorldParamId _ WorldParamName _ WorldParamExpanded _ Action19)> */
		nil,
		/* 27 ItemParams <- <ItemParam+> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position247 := position
					{
						position248, tokenIndex248 := position, tokenIndex
						if !_rules[ruleEXTERNAL]() {
							goto l249
						}
						if !_rules[ruleEQUALS]() {
							goto l249
						}
						{
							position250 := position
							if !_rules[ruleBoolean]() {
								goto l249
							}
							add(rulePegText, position250)
						}
						{
							add(ruleAction24, position)
						}
						goto l248
					l249:
						position, tokenIndex = position248, tokenIndex248
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l243
								}
								if !_rules[ruleEQUALS]() {
									goto l243
								}
								{
									position253 := position
									if !_rules[ruleStringLike]() {
										goto l243
									}
									add(rulePegText, position253)
								}
								{
									add(ruleAction28, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l243
								}
								if !_rules[ruleEQUALS]() {
									goto l243
								}
								{
									position255 := position
									if !_rules[ruleStringLike]() {
										goto l243
									}
									add(rulePegText, position255)
								}
								{
									add(ruleAction27, position)
								}
							case 'n':
								if !_rules[ruleNAME]() {
									goto l243
								}
								if !_rules[ruleEQUALS]() {
									goto l243
								}
								{
									position257 := position
									if !_rules[ruleStringLike]() {
										goto l243
									}
									add(rulePegText, position257)
								}
								{
									add(ruleAction26, position)
								}
							default:
								if !_rules[ruleTYPE]() {
									goto l243
								}
								if !_rules[ruleEQUALS]() {
									goto l243
								}
								{
									position259 := position
									{
										position260 := position
										{
											position261, tokenIndex261 := position, tokenIndex
											{
												position263 := position
												if buffer[position] != rune('d') {
													goto l262
												}
												position++
												if buffer[position] != rune('a') {
													goto l262
												}
												position++
												if buffer[position] != rune('t') {
													goto l262
												}
												position++
												if buffer[position] != rune('a') {
													goto l262
												}
												position++
												if buffer[position] != rune('b') {
													goto l262
												}
												position++
												if buffer[position] != rune('a') {
													goto l262
												}
												position++
												if buffer[position] != rune('s') {
													goto l262
												}
												position++
												if buffer[position] != rune('e') {
													goto l262
												}
												position++
												if !_rules[rule_]() {
													goto l262
												}
												add(ruleDATABASE, position263)
											}
											goto l261
										l262:
											position, tokenIndex = position261, tokenIndex261
											{
												position265 := position
												if buffer[position] != rune('b') {
													goto l264
												}
												position++
												if buffer[position] != rune('l') {
													goto l264
												}
												position++
												if buffer[position] != rune('o') {
													goto l264
												}
												position++
												if buffer[position] != rune('b') {
													goto l264
												}
												position++
												if buffer[position] != rune('s') {
													goto l264
												}
												position++
												if buffer[position] != rune('t') {
													goto l264
												}
												position++
												if buffer[position] != rune('o') {
													goto l264
												}
												position++
												if buffer[position] != rune('r') {
													goto l264
												}
												position++
												if buffer[position] != rune('e') {
													goto l264
												}
												position++
												if !_rules[rule_]() {
													goto l264
												}
												add(ruleBLOBSTORE, position265)
											}
											goto l261
										l264:
											position, tokenIndex = position261, tokenIndex261
											{
												switch buffer[position] {
												case 'c':
													{
														position267 := position
														if buffer[position] != rune('c') {
															goto l243
														}
														position++
														if buffer[position] != rune('o') {
															goto l243
														}
														position++
														if buffer[position] != rune('d') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleCODE, position267)
													}
												case 'd':
													{
														position268 := position
														if buffer[position] != rune('d') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('v') {
															goto l243
														}
														position++
														if buffer[position] != rune('i') {
															goto l243
														}
														position++
														if buffer[position] != rune('c') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleDEVICE, position268)
													}
												case 's':
													{
														position269 := position
														if buffer[position] != rune('s') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('r') {
															goto l243
														}
														position++
														if buffer[position] != rune('v') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('r') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleSERVER, position269)
													}
												case 'm':
													{
														position270 := position
														if buffer[position] != rune('m') {
															goto l243
														}
														position++
														if buffer[position] != rune('o') {
															goto l243
														}
														position++
														if buffer[position] != rune('b') {
															goto l243
														}
														position++
														if buffer[position] != rune('i') {
															goto l243
														}
														position++
														if buffer[position] != rune('l') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleMOBILE, position270)
													}
												case 'b':
													{
														position271 := position
														if buffer[position] != rune('b') {
															goto l243
														}
														position++
														if buffer[position] != rune('r') {
															goto l243
														}
														position++
														if buffer[position] != rune('o') {
															goto l243
														}
														position++
														if buffer[position] != rune('w') {
															goto l243
														}
														position++
														if buffer[position] != rune('s') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('r') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleBROWSER, position271)
													}
												case 'q':
													{
														position272 := position
														if buffer[position] != rune('q') {
															goto l243
														}
														position++
														if buffer[position] != rune('u') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('u') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(ruleQUEUE, position272)
													}
												default:
													{
														position273 := position
														if buffer[position] != rune('p') {
															goto l243
														}
														position++
														if buffer[position] != rune('e') {
															goto l243
														}
														position++
														if buffer[position] != rune('r') {
															goto l243
														}
														position++
														if buffer[position] != rune('s') {
															goto l243
														}
														position++
														if buffer[position] != rune('o') {
															goto l243
														}
														position++
														if buffer[position] != rune('n') {
															goto l243
														}
														position++
														if !_rules[rule_]() {
															goto l243
														}
														add(rulePERSON, position273)
													}
												}
											}

										}
									l261:
										add(ruleItemType, position260)
									}
									add(rulePegText, position259)
								}
								{
									add(ruleAction25, position)
								}
							}
						}

					}
				l248:
					add(ruleItemParam, position247)
				}
			l245:
				{
					position246, tokenIndex246 := position, tokenIndex
					{
						position275 := position
						{
							position276, tokenIndex276 := position, tokenIndex
							if !_rules[ruleEXTERNAL]() {
								goto l277
							}
							if !_rules[ruleEQUALS]() {
								goto l277
							}
							{
								position278 := position
								if !_rules[ruleBoolean]() {
									goto l277
								}
								add(rulePegText, position278)
							}
							{
								add(ruleAction24, position)
							}
							goto l276
						l277:
							position, tokenIndex = position276, tokenIndex276
							{
								switch buffer[position] {
								case 'e':
									if !_rules[ruleEXPANDED]() {
										goto l246
									}
									if !_rules[ruleEQUALS]() {
										goto l246
									}
									{
										position281 := position
										if !_rules[ruleStringLike]() {
											goto l246
										}
										add(rulePegText, position281)
									}
									{
										add(ruleAction28, position)
									}
								case 'm':
									if !_rules[ruleMECHANISM]() {
										goto l246
									}
									if !_rules[ruleEQUALS]() {
										goto l246
									}
									{
										position283 := position
										if !_rules[ruleStringLike]() {
											goto l246
										}
										add(rulePegText, position283)
									}
									{
										add(ruleAction27, position)
									}
								case 'n':
									if !_rules[ruleNAME]() {
										goto l246
									}
									if !_rules[ruleEQUALS]() {
										goto l246
									}
									{
										position285 := position
										if !_rules[ruleStringLike]() {
											goto l246
										}
										add(rulePegText, position285)
									}
									{
										add(ruleAction26, position)
									}
								default:
									if !_rules[ruleTYPE]() {
										goto l246
									}
									if !_rules[ruleEQUALS]() {
										goto l246
									}
									{
										position287 := position
										{
											position288 := position
											{
												position289, tokenIndex289 := position, tokenIndex
												{
													position291 := position
													if buffer[position] != rune('d') {
														goto l290
													}
													position++
													if buffer[position] != rune('a') {
														goto l290
													}
													position++
													if buffer[position] != rune('t') {
														goto l290
													}
													position++
													if buffer[position] != rune('a') {
														goto l290
													}
													position++
													if buffer[position] != rune('b') {
														goto l290
													}
													position++
													if buffer[position] != rune('a') {
														goto l290
													}
													position++
													if buffer[position] != rune('s') {
														goto l290
													}
													position++
													if buffer[position] != rune('e') {
														goto l290
													}
													position++
													if !_rules[rule_]() {
														goto l290
													}
													add(ruleDATABASE, position291)
												}
												goto l289
											l290:
												position, tokenIndex = position289, tokenIndex289
												{
													position293 := position
													if buffer[position] != rune('b') {
														goto l292
													}
													position++
													if buffer[position] != rune('l') {
														goto l292
													}
													position++
													if buffer[position] != rune('o') {
														goto l292
													}
													position++
													if buffer[position] != rune('b') {
														goto l292
													}
													position++
													if buffer[position] != rune('s') {
														goto l292
													}
													position++
													if buffer[position] != rune('t') {
														goto l292
													}
													position++
													if buffer[position] != rune('o') {
														goto l292
													}
													position++
													if buffer[position] != rune('r') {
														goto l292
													}
													position++
													if buffer[position] != rune('e') {
														goto l292
													}
													position++
													if !_rules[rule_]() {
														goto l292
													}
													add(ruleBLOBSTORE, position293)
												}
												goto l289
											l292:
												position, tokenIndex = position289, tokenIndex289
												{
													switch buffer[position] {
													case 'c':
														{
															position295 := position
															if buffer[position] != rune('c') {
																goto l246
															}
															position++
															if buffer[position] != rune('o') {
																goto l246
															}
															position++
															if buffer[position] != rune('d') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleCODE, position295)
														}
													case 'd':
														{
															position296 := position
															if buffer[position] != rune('d') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('v') {
																goto l246
															}
															position++
															if buffer[position] != rune('i') {
																goto l246
															}
															position++
															if buffer[position] != rune('c') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleDEVICE, position296)
														}
													case 's':
														{
															position297 := position
															if buffer[position] != rune('s') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('r') {
																goto l246
															}
															position++
															if buffer[position] != rune('v') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('r') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleSERVER, position297)
														}
													case 'm':
														{
															position298 := position
															if buffer[position] != rune('m') {
																goto l246
															}
															position++
															if buffer[position] != rune('o') {
																goto l246
															}
															position++
															if buffer[position] != rune('b') {
																goto l246
															}
															position++
															if buffer[position] != rune('i') {
																goto l246
															}
															position++
															if buffer[position] != rune('l') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleMOBILE, position298)
														}
													case 'b':
														{
															position299 := position
															if buffer[position] != rune('b') {
																goto l246
															}
															position++
															if buffer[position] != rune('r') {
																goto l246
															}
															position++
															if buffer[position] != rune('o') {
																goto l246
															}
															position++
															if buffer[position] != rune('w') {
																goto l246
															}
															position++
															if buffer[position] != rune('s') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('r') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleBROWSER, position299)
														}
													case 'q':
														{
															position300 := position
															if buffer[position] != rune('q') {
																goto l246
															}
															position++
															if buffer[position] != rune('u') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('u') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(ruleQUEUE, position300)
														}
													default:
														{
															position301 := position
															if buffer[position] != rune('p') {
																goto l246
															}
															position++
															if buffer[position] != rune('e') {
																goto l246
															}
															position++
															if buffer[position] != rune('r') {
																goto l246
															}
															position++
															if buffer[position] != rune('s') {
																goto l246
															}
															position++
															if buffer[position] != rune('o') {
																goto l246
															}
															position++
															if buffer[position] != rune('n') {
																goto l246
															}
															position++
															if !_rules[rule_]() {
																goto l246
															}
															add(rulePERSON, position301)
														}
													}
												}

											}
										l289:
											add(ruleItemType, position288)
										}
										add(rulePegText, position287)
									}
									{
										add(ruleAction25, position)
									}
								}
							}

						}
					l276:
						add(ruleItemParam, position275)
					}
					goto l245
				l246:
					position, tokenIndex = position246, tokenIndex246
				}
				add(ruleItemParams, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 28 RelParams <- <RelParam+> */
		func() bool {
			position303, tokenIndex303 := position, tokenIndex
			{
				position304 := position
				{
					position307 := position
					{
						switch buffer[position] {
						case 'e':
							if !_rules[ruleEXPANDED]() {
								goto l303
							}
							if !_rules[ruleEQUALS]() {
								goto l303
							}
							{
								position309 := position
								if !_rules[ruleStringLike]() {
									goto l303
								}
								add(rulePegText, position309)
							}
							{
								add(ruleAction32, position)
							}
						case 'a':
							if !_rules[ruleASYNC]() {
								goto l303
							}
							if !_rules[ruleEQUALS]() {
								goto l303
							}
							{
								position311 := position
								if !_rules[ruleBoolean]() {
									goto l303
								}
								add(rulePegText, position311)
							}
							{
								add(ruleAction31, position)
							}
						case 'm':
							if !_rules[ruleMECHANISM]() {
								goto l303
							}
							if !_rules[ruleEQUALS]() {
								goto l303
							}
							{
								position313 := position
								if !_rules[ruleStringLike]() {
									goto l303
								}
								add(rulePegText, position313)
							}
							{
								add(ruleAction30, position)
							}
						default:
							if !_rules[ruleVERB]() {
								goto l303
							}
							if !_rules[ruleEQUALS]() {
								goto l303
							}
							{
								position315 := position
								if !_rules[ruleStringLike]() {
									goto l303
								}
								add(rulePegText, position315)
							}
							{
								add(ruleAction29, position)
							}
						}
					}

					add(ruleRelParam, position307)
				}
			l305:
				{
					position306, tokenIndex306 := position, tokenIndex
					{
						position317 := position
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l306
								}
								if !_rules[ruleEQUALS]() {
									goto l306
								}
								{
									position319 := position
									if !_rules[ruleStringLike]() {
										goto l306
									}
									add(rulePegText, position319)
								}
								{
									add(ruleAction32, position)
								}
							case 'a':
								if !_rules[ruleASYNC]() {
									goto l306
								}
								if !_rules[ruleEQUALS]() {
									goto l306
								}
								{
									position321 := position
									if !_rules[ruleBoolean]() {
										goto l306
									}
									add(rulePegText, position321)
								}
								{
									add(ruleAction31, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l306
								}
								if !_rules[ruleEQUALS]() {
									goto l306
								}
								{
									position323 := position
									if !_rules[ruleStringLike]() {
										goto l306
									}
									add(rulePegText, position323)
								}
								{
									add(ruleAction30, position)
								}
							default:
								if !_rules[ruleVERB]() {
									goto l306
								}
								if !_rules[ruleEQUALS]() {
									goto l306
								}
								{
									position325 := position
									if !_rules[ruleStringLike]() {
										goto l306
									}
									add(rulePegText, position325)
								}
								{
									add(ruleAction29, position)
								}
							}
						}

						add(ruleRelParam, position317)
					}
					goto l305
				l306:
					position, tokenIndex = position306, tokenIndex306
				}
				add(ruleRelParams, position304)
			}
			return true
		l303:
			position, tokenIndex = position303, tokenIndex303
			return false
		},
		/* 29 WorldParamVersion <- <(VERSION EQUALS <Number> Action20)> */
		nil,
		/* 30 WorldParamId <- <(ID EQUALS <StringLike> Action21)> */
		nil,
		/* 31 WorldParamName <- <(NAME EQUALS <StringLike?> Action22)> */
		nil,
		/* 32 WorldParamExpanded <- <(EXPANDED EQUALS <StringLike?> Action23)> */
		nil,
		/* 33 ItemParam <- <((EXTERNAL EQUALS <Boolean> Action24) / ((&('e') (EXPANDED EQUALS <StringLike> Action28)) | (&('m') (MECHANISM EQUALS <StringLike> Action27)) | (&('n') (NAME EQUALS <StringLike> Action26)) | (&('t') (TYPE EQUALS <ItemType> Action25))))> */
		nil,
		/* 34 RelParam <- <((&('e') (EXPANDED EQUALS <StringLike> Action32)) | (&('a') (ASYNC EQUALS <Boolean> Action31)) | (&('m') (MECHANISM EQUALS <StringLike> Action30)) | (&('v') (VERB EQUALS <StringLike> Action29)))> */
		nil,
		/* 35 ItemKeys <- <ItemKey+> */
		nil,
		/* 36 RelKeys <- <RelKey+> */
		nil,
		/* 37 ItemKey <- <(<(EXTERNAL / ((&('e') EXPANDED) | (&('m') MECHANISM) | (&('t') TYPE) | (&('n') NAME)))> _ Action33)> */
		nil,
		/* 38 RelKey <- <(<((&('e') EXPANDED) | (&('a') ASYNC) | (&('m') MECHANISM) | (&('v') VERB))> _ Action34)> */
		nil,
		/* 39 StringLike <- <(<(Text / QuotedText)> _ Action35)> */
		func() bool {
			position337, tokenIndex337 := position, tokenIndex
			{
				position338 := position
				{
					position339 := position
					{
						position340, tokenIndex340 := position, tokenIndex
						{
							position342 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l341
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l341
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l341
									}
									position++
								case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l341
									}
									position++
								default:
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l341
									}
									position++
								}
							}

						l343:
							{
								position344, tokenIndex344 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l344
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l344
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l344
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l344
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l344
										}
										position++
									}
								}

								goto l343
							l344:
								position, tokenIndex = position344, tokenIndex344
							}
							add(ruleText, position342)
						}
						goto l340
					l341:
						position, tokenIndex = position340, tokenIndex340
						{
							position347 := position
							if !_rules[ruleQUOTE]() {
								goto l337
							}
						l348:
							{
								position349, tokenIndex349 := position, tokenIndex
								{
									switch buffer[position] {
									case ' ':
										if buffer[position] != rune(' ') {
											goto l349
										}
										position++
									case ':':
										if buffer[position] != rune(':') {
											goto l349
										}
										position++
									case ';':
										if buffer[position] != rune(';') {
											goto l349
										}
										position++
									case '~':
										if buffer[position] != rune('~') {
											goto l349
										}
										position++
									case '=':
										if buffer[position] != rune('=') {
											goto l349
										}
										position++
									case '+':
										if buffer[position] != rune('+') {
											goto l349
										}
										position++
									case ']':
										if buffer[position] != rune(']') {
											goto l349
										}
										position++
									case '[':
										if buffer[position] != rune('[') {
											goto l349
										}
										position++
									case ')':
										if buffer[position] != rune(')') {
											goto l349
										}
										position++
									case '(':
										if buffer[position] != rune('(') {
											goto l349
										}
										position++
									case '*':
										if buffer[position] != rune('*') {
											goto l349
										}
										position++
									case '&':
										if buffer[position] != rune('&') {
											goto l349
										}
										position++
									case '^':
										if buffer[position] != rune('^') {
											goto l349
										}
										position++
									case '%':
										if buffer[position] != rune('%') {
											goto l349
										}
										position++
									case '$':
										if buffer[position] != rune('$') {
											goto l349
										}
										position++
									case '#':
										if buffer[position] != rune('#') {
											goto l349
										}
										position++
									case '@':
										if buffer[position] != rune('@') {
											goto l349
										}
										position++
									case '!':
										if buffer[position] != rune('!') {
											goto l349
										}
										position++
									case ',':
										if buffer[position] != rune(',') {
											goto l349
										}
										position++
									case '.':
										if buffer[position] != rune('.') {
											goto l349
										}
										position++
									case '_':
										if buffer[position] != rune('_') {
											goto l349
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l349
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l349
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l349
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l349
										}
										position++
									}
								}

								goto l348
							l349:
								position, tokenIndex = position349, tokenIndex349
							}
							if !_rules[ruleQUOTE]() {
								goto l337
							}
							add(ruleQuotedText, position347)
						}
					}
				l340:
					add(rulePegText, position339)
				}
				if !_rules[rule_]() {
					goto l337
				}
				{
					add(ruleAction35, position)
				}
				add(ruleStringLike, position338)
			}
			return true
		l337:
			position, tokenIndex = position337, tokenIndex337
			return false
		},
		/* 40 Number <- <(<[0-9]+> _ Action36)> */
		func() bool {
			position352, tokenIndex352 := position, tokenIndex
			{
				position353 := position
				{
					position354 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l352
					}
					position++
				l355:
					{
						position356, tokenIndex356 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l356
						}
						position++
						goto l355
					l356:
						position, tokenIndex = position356, tokenIndex356
					}
					add(rulePegText, position354)
				}
				if !_rules[rule_]() {
					goto l352
				}
				{
					add(ruleAction36, position)
				}
				add(ruleNumber, position353)
			}
			return true
		l352:
			position, tokenIndex = position352, tokenIndex352
			return false
		},
		/* 41 Boolean <- <(<(TRUE / FALSE)> Action37)> */
		func() bool {
			position358, tokenIndex358 := position, tokenIndex
			{
				position359 := position
				{
					position360 := position
					{
						position361, tokenIndex361 := position, tokenIndex
						{
							position363 := position
							if buffer[position] != rune('t') {
								goto l362
							}
							position++
							if buffer[position] != rune('r') {
								goto l362
							}
							position++
							if buffer[position] != rune('u') {
								goto l362
							}
							position++
							if buffer[position] != rune('e') {
								goto l362
							}
							position++
							if !_rules[rule_]() {
								goto l362
							}
							add(ruleTRUE, position363)
						}
						goto l361
					l362:
						position, tokenIndex = position361, tokenIndex361
						{
							position364 := position
							if buffer[position] != rune('f') {
								goto l358
							}
							position++
							if buffer[position] != rune('a') {
								goto l358
							}
							position++
							if buffer[position] != rune('l') {
								goto l358
							}
							position++
							if buffer[position] != rune('s') {
								goto l358
							}
							position++
							if buffer[position] != rune('e') {
								goto l358
							}
							position++
							if !_rules[rule_]() {
								goto l358
							}
							add(ruleFALSE, position364)
						}
					}
				l361:
					add(rulePegText, position360)
				}
				{
					add(ruleAction37, position)
				}
				add(ruleBoolean, position359)
			}
			return true
		l358:
			position, tokenIndex = position358, tokenIndex358
			return false
		},
		/* 42 Text <- <((&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> */
		nil,
		/* 43 QuotedText <- <(QUOTE ((&(' ') ' ') | (&(':') ':') | (&(';') ';') | (&('~') '~') | (&('=') '=') | (&('+') '+') | (&(']') ']') | (&('[') '[') | (&(')') ')') | (&('(') '(') | (&('*') '*') | (&('&') '&') | (&('^') '^') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('@') '@') | (&('!') '!') | (&(',') ',') | (&('.') '.') | (&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))* QUOTE)> */
		nil,
		/* 44 ItemExists <- <((ITEM_EXISTS / (Item Exists)) Action38)> */
		nil,
		/* 45 RelExists <- <((REL_EXISTS / (Rel Exists)) Action39)> */
		nil,
		/* 46 World <- <(WORLD Action40)> */
		nil,
		/* 47 Item <- <(ITEM Action41)> */
		func() bool {
			position371, tokenIndex371 := position, tokenIndex
			{
				position372 := position
				if !_rules[ruleITEM]() {
					goto l371
				}
				{
					add(ruleAction41, position)
				}
				add(ruleItem, position372)
			}
			return true
		l371:
			position, tokenIndex = position371, tokenIndex371
			return false
		},
		/* 48 Rel <- <(REL Action42)> */
		func() bool {
			position374, tokenIndex374 := position, tokenIndex
			{
				position375 := position
				if !_rules[ruleREL]() {
					goto l374
				}
				{
					add(ruleAction42, position)
				}
				add(ruleRel, position375)
			}
			return true
		l374:
			position, tokenIndex = position374, tokenIndex374
			return false
		},
		/* 49 Create <- <(CREATE Action43)> */
		func() bool {
			position377, tokenIndex377 := position, tokenIndex
			{
				position378 := position
				if !_rules[ruleCREATE]() {
					goto l377
				}
				{
					add(ruleAction43, position)
				}
				add(ruleCreate, position378)
			}
			return true
		l377:
			position, tokenIndex = position377, tokenIndex377
			return false
		},
		/* 50 Fetch <- <(FETCH Action44)> */
		func() bool {
			position380, tokenIndex380 := position, tokenIndex
			{
				position381 := position
				if !_rules[ruleFETCH]() {
					goto l380
				}
				{
					add(ruleAction44, position)
				}
				add(ruleFetch, position381)
			}
			return true
		l380:
			position, tokenIndex = position380, tokenIndex380
			return false
		},
		/* 51 Set <- <(SET Action45)> */
		func() bool {
			position383, tokenIndex383 := position, tokenIndex
			{
				position384 := position
				if !_rules[ruleSET]() {
					goto l383
				}
				{
					add(ruleAction45, position)
				}
				add(ruleSet, position384)
			}
			return true
		l383:
			position, tokenIndex = position383, tokenIndex383
			return false
		},
		/* 52 Clear <- <(CLEAR Action46)> */
		func() bool {
			position386, tokenIndex386 := position, tokenIndex
			{
				position387 := position
				if !_rules[ruleCLEAR]() {
					goto l386
				}
				{
					add(ruleAction46, position)
				}
				add(ruleClear, position387)
			}
			return true
		l386:
			position, tokenIndex = position386, tokenIndex386
			return false
		},
		/* 53 Delete <- <(DELETE Action47)> */
		func() bool {
			position389, tokenIndex389 := position, tokenIndex
			{
				position390 := position
				if !_rules[ruleDELETE]() {
					goto l389
				}
				{
					add(ruleAction47, position)
				}
				add(ruleDelete, position390)
			}
			return true
		l389:
			position, tokenIndex = position389, tokenIndex389
			return false
		},
		/* 54 List <- <(LIST Action48)> */
		nil,
		/* 55 Nest <- <(NEST Action49)> */
		nil,
		/* 56 Free <- <(FREE Action50)> */
		nil,
		/* 57 Exists <- <(EXISTS Action51)> */
		func() bool {
			position395, tokenIndex395 := position, tokenIndex
			{
				position396 := position
				if !_rules[ruleEXISTS]() {
					goto l395
				}
				{
					add(ruleAction51, position)
				}
				add(ruleExists, position396)
			}
			return true
		l395:
			position, tokenIndex = position395, tokenIndex395
			return false
		},
		/* 58 InQuery <- <(IN_QUERY Action52)> */
		nil,
		/* 59 FromQuery <- <(FROM_QUERY Action53)> */
		nil,
		/* 60 ToQuery <- <(TO_QUERY Action54)> */
		nil,
		/* 61 Flag <- <(StrictFlag / VerboseFlag / IdsFlag)> */
		nil,
		/* 62 StrictFlag <- <(FLAG STRICT Action55)> */
		nil,
		/* 63 VerboseFlag <- <(FLAG VERBOSE Action56)> */
		nil,
		/* 64 IdsFlag <- <(FLAG IDS Action57)> */
		nil,
		/* 65 BeginWorld <- <(_ DELIMITER WORLD _)> */
		nil,
		/* 66 EndWorld <- <(_ ENDWORLD DELIMITER _)> */
		nil,
		/* 67 ItemType <- <(DATABASE / BLOBSTORE / ((&('c') CODE) | (&('d') DEVICE) | (&('s') SERVER) | (&('m') MOBILE) | (&('b') BROWSER) | (&('q') QUEUE) | (&('p') PERSON)))> */
		nil,
		/* 68 Keyword <- <(ENDWORLD / ERROR / ITEM / ITEM_EXISTS / REL / FROM_QUERY / IN / CREATE / FETCH / ((&('$') DELIMITER) | (&('-') FLAG) | (&('n') NEST) | (&('f') FREE) | (&('e') EXISTS) | (&('l') LIST) | (&('c') CLEAR) | (&('s') SET) | (&('d') DELETE) | (&('i') IN_QUERY) | (&('t') TO_QUERY) | (&('r') REL_EXISTS) | (&('o') OK) | (&('w') WORLD)))> */
		func() bool {
			position408, tokenIndex408 := position, tokenIndex
			{
				position409 := position
				{
					position410, tokenIndex410 := position, tokenIndex
					if !_rules[ruleENDWORLD]() {
						goto l411
					}
					goto l410
				l411:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleERROR]() {
						goto l412
					}
					goto l410
				l412:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleITEM]() {
						goto l413
					}
					goto l410
				l413:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleITEM_EXISTS]() {
						goto l414
					}
					goto l410
				l414:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleREL]() {
						goto l415
					}
					goto l410
				l415:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleFROM_QUERY]() {
						goto l416
					}
					goto l410
				l416:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleIN]() {
						goto l417
					}
					goto l410
				l417:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleCREATE]() {
						goto l418
					}
					goto l410
				l418:
					position, tokenIndex = position410, tokenIndex410
					if !_rules[ruleFETCH]() {
						goto l419
					}
					goto l410
				l419:
					position, tokenIndex = position410, tokenIndex410
					{
						switch buffer[position] {
						case '$':
							if !_rules[ruleDELIMITER]() {
								goto l408
							}
						case '-':
							if !_rules[ruleFLAG]() {
								goto l408
							}
						case 'n':
							if !_rules[ruleNEST]() {
								goto l408
							}
						case 'f':
							if !_rules[ruleFREE]() {
								goto l408
							}
						case 'e':
							if !_rules[ruleEXISTS]() {
								goto l408
							}
						case 'l':
							if !_rules[ruleLIST]() {
								goto l408
							}
						case 'c':
							if !_rules[ruleCLEAR]() {
								goto l408
							}
						case 's':
							if !_rules[ruleSET]() {
								goto l408
							}
						case 'd':
							if !_rules[ruleDELETE]() {
								goto l408
							}
						case 'i':
							if !_rules[ruleIN_QUERY]() {
								goto l408
							}
						case 't':
							if !_rules[ruleTO_QUERY]() {
								goto l408
							}
						case 'r':
							if !_rules[ruleREL_EXISTS]() {
								goto l408
							}
						case 'o':
							if !_rules[ruleOK]() {
								goto l408
							}
						default:
							if !_rules[ruleWORLD]() {
								goto l408
							}
						}
					}

				}
			l410:
				add(ruleKeyword, position409)
			}
			return true
		l408:
			position, tokenIndex = position408, tokenIndex408
			return false
		},
		/* 69 WORLD <- <('w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position421, tokenIndex421 := position, tokenIndex
			{
				position422 := position
				if buffer[position] != rune('w') {
					goto l421
				}
				position++
				if buffer[position] != rune('o') {
					goto l421
				}
				position++
				if buffer[position] != rune('r') {
					goto l421
				}
				position++
				if buffer[position] != rune('l') {
					goto l421
				}
				position++
				if buffer[position] != rune('d') {
					goto l421
				}
				position++
				if !_rules[rule_]() {
					goto l421
				}
				add(ruleWORLD, position422)
			}
			return true
		l421:
			position, tokenIndex = position421, tokenIndex421
			return false
		},
		/* 70 ENDWORLD <- <('e' 'n' 'd' 'w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position423, tokenIndex423 := position, tokenIndex
			{
				position424 := position
				if buffer[position] != rune('e') {
					goto l423
				}
				position++
				if buffer[position] != rune('n') {
					goto l423
				}
				position++
				if buffer[position] != rune('d') {
					goto l423
				}
				position++
				if buffer[position] != rune('w') {
					goto l423
				}
				position++
				if buffer[position] != rune('o') {
					goto l423
				}
				position++
				if buffer[position] != rune('r') {
					goto l423
				}
				position++
				if buffer[position] != rune('l') {
					goto l423
				}
				position++
				if buffer[position] != rune('d') {
					goto l423
				}
				position++
				if !_rules[rule_]() {
					goto l423
				}
				add(ruleENDWORLD, position424)
			}
			return true
		l423:
			position, tokenIndex = position423, tokenIndex423
			return false
		},
		/* 71 ERROR <- <('e' 'r' 'r' 'o' 'r' _)> */
		func() bool {
			position425, tokenIndex425 := position, tokenIndex
			{
				position426 := position
				if buffer[position] != rune('e') {
					goto l425
				}
				position++
				if buffer[position] != rune('r') {
					goto l425
				}
				position++
				if buffer[position] != rune('r') {
					goto l425
				}
				position++
				if buffer[position] != rune('o') {
					goto l425
				}
				position++
				if buffer[position] != rune('r') {
					goto l425
				}
				position++
				if !_rules[rule_]() {
					goto l425
				}
				add(ruleERROR, position426)
			}
			return true
		l425:
			position, tokenIndex = position425, tokenIndex425
			return false
		},
		/* 72 OK <- <('o' 'k' _)> */
		func() bool {
			position427, tokenIndex427 := position, tokenIndex
			{
				position428 := position
				if buffer[position] != rune('o') {
					goto l427
				}
				position++
				if buffer[position] != rune('k') {
					goto l427
				}
				position++
				if !_rules[rule_]() {
					goto l427
				}
				add(ruleOK, position428)
			}
			return true
		l427:
			position, tokenIndex = position427, tokenIndex427
			return false
		},
		/* 73 ITEM <- <('i' 't' 'e' 'm' 's'? _)> */
		func() bool {
			position429, tokenIndex429 := position, tokenIndex
			{
				position430 := position
				if buffer[position] != rune('i') {
					goto l429
				}
				position++
				if buffer[position] != rune('t') {
					goto l429
				}
				position++
				if buffer[position] != rune('e') {
					goto l429
				}
				position++
				if buffer[position] != rune('m') {
					goto l429
				}
				position++
				{
					position431, tokenIndex431 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l431
					}
					position++
					goto l432
				l431:
					position, tokenIndex = position431, tokenIndex431
				}
			l432:
				if !_rules[rule_]() {
					goto l429
				}
				add(ruleITEM, position430)
			}
			return true
		l429:
			position, tokenIndex = position429, tokenIndex429
			return false
		},
		/* 74 ITEM_EXISTS <- <('i' 't' 'e' 'm' '?' _)> */
		func() bool {
			position433, tokenIndex433 := position, tokenIndex
			{
				position434 := position
				if buffer[position] != rune('i') {
					goto l433
				}
				position++
				if buffer[position] != rune('t') {
					goto l433
				}
				position++
				if buffer[position] != rune('e') {
					goto l433
				}
				position++
				if buffer[position] != rune('m') {
					goto l433
				}
				position++
				if buffer[position] != rune('?') {
					goto l433
				}
				position++
				if !_rules[rule_]() {
					goto l433
				}
				add(ruleITEM_EXISTS, position434)
			}
			return true
		l433:
			position, tokenIndex = position433, tokenIndex433
			return false
		},
		/* 75 REL <- <('r' 'e' 'l' 's'? _)> */
		func() bool {
			position435, tokenIndex435 := position, tokenIndex
			{
				position436 := position
				if buffer[position] != rune('r') {
					goto l435
				}
				position++
				if buffer[position] != rune('e') {
					goto l435
				}
				position++
				if buffer[position] != rune('l') {
					goto l435
				}
				position++
				{
					position437, tokenIndex437 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l437
					}
					position++
					goto l438
				l437:
					position, tokenIndex = position437, tokenIndex437
				}
			l438:
				if !_rules[rule_]() {
					goto l435
				}
				add(ruleREL, position436)
			}
			return true
		l435:
			position, tokenIndex = position435, tokenIndex435
			return false
		},
		/* 76 REL_EXISTS <- <('r' 'e' 'l' '?' _)> */
		func() bool {
			position439, tokenIndex439 := position, tokenIndex
			{
				position440 := position
				if buffer[position] != rune('r') {
					goto l439
				}
				position++
				if buffer[position] != rune('e') {
					goto l439
				}
				position++
				if buffer[position] != rune('l') {
					goto l439
				}
				position++
				if buffer[position] != rune('?') {
					goto l439
				}
				position++
				if !_rules[rule_]() {
					goto l439
				}
				add(ruleREL_EXISTS, position440)
			}
			return true
		l439:
			position, tokenIndex = position439, tokenIndex439
			return false
		},
		/* 77 FROM_QUERY <- <('f' 'r' 'o' 'm' '?' _)> */
		func() bool {
			position441, tokenIndex441 := position, tokenIndex
			{
				position442 := position
				if buffer[position] != rune('f') {
					goto l441
				}
				position++
				if buffer[position] != rune('r') {
					goto l441
				}
				position++
				if buffer[position] != rune('o') {
					goto l441
				}
				position++
				if buffer[position] != rune('m') {
					goto l441
				}
				position++
				if buffer[position] != rune('?') {
					goto l441
				}
				position++
				if !_rules[rule_]() {
					goto l441
				}
				add(ruleFROM_QUERY, position442)
			}
			return true
		l441:
			position, tokenIndex = position441, tokenIndex441
			return false
		},
		/* 78 TO_QUERY <- <('t' 'o' '?' _)> */
		func() bool {
			position443, tokenIndex443 := position, tokenIndex
			{
				position444 := position
				if buffer[position] != rune('t') {
					goto l443
				}
				position++
				if buffer[position] != rune('o') {
					goto l443
				}
				position++
				if buffer[position] != rune('?') {
					goto l443
				}
				position++
				if !_rules[rule_]() {
					goto l443
				}
				add(ruleTO_QUERY, position444)
			}
			return true
		l443:
			position, tokenIndex = position443, tokenIndex443
			return false
		},
		/* 79 IN <- <('i' 'n' _)> */
		func() bool {
			position445, tokenIndex445 := position, tokenIndex
			{
				position446 := position
				if buffer[position] != rune('i') {
					goto l445
				}
				position++
				if buffer[position] != rune('n') {
					goto l445
				}
				position++
				if !_rules[rule_]() {
					goto l445
				}
				add(ruleIN, position446)
			}
			return true
		l445:
			position, tokenIndex = position445, tokenIndex445
			return false
		},
		/* 80 IN_QUERY <- <('i' 'n' '?' _)> */
		func() bool {
			position447, tokenIndex447 := position, tokenIndex
			{
				position448 := position
				if buffer[position] != rune('i') {
					goto l447
				}
				position++
				if buffer[position] != rune('n') {
					goto l447
				}
				position++
				if buffer[position] != rune('?') {
					goto l447
				}
				position++
				if !_rules[rule_]() {
					goto l447
				}
				add(ruleIN_QUERY, position448)
			}
			return true
		l447:
			position, tokenIndex = position447, tokenIndex447
			return false
		},
		/* 81 CREATE <- <('c' 'r' 'e' 'a' 't' 'e' _)> */
		func() bool {
			position449, tokenIndex449 := position, tokenIndex
			{
				position450 := position
				if buffer[position] != rune('c') {
					goto l449
				}
				position++
				if buffer[position] != rune('r') {
					goto l449
				}
				position++
				if buffer[position] != rune('e') {
					goto l449
				}
				position++
				if buffer[position] != rune('a') {
					goto l449
				}
				position++
				if buffer[position] != rune('t') {
					goto l449
				}
				position++
				if buffer[position] != rune('e') {
					goto l449
				}
				position++
				if !_rules[rule_]() {
					goto l449
				}
				add(ruleCREATE, position450)
			}
			return true
		l449:
			position, tokenIndex = position449, tokenIndex449
			return false
		},
		/* 82 DELETE <- <('d' 'e' 'l' 'e' 't' 'e' _)> */
		func() bool {
			position451, tokenIndex451 := position, tokenIndex
			{
				position452 := position
				if buffer[position] != rune('d') {
					goto l451
				}
				position++
				if buffer[position] != rune('e') {
					goto l451
				}
				position++
				if buffer[position] != rune('l') {
					goto l451
				}
				position++
				if buffer[position] != rune('e') {
					goto l451
				}
				position++
				if buffer[position] != rune('t') {
					goto l451
				}
				position++
				if buffer[position] != rune('e') {
					goto l451
				}
				position++
				if !_rules[rule_]() {
					goto l451
				}
				add(ruleDELETE, position452)
			}
			return true
		l451:
			position, tokenIndex = position451, tokenIndex451
			return false
		},
		/* 83 SET <- <('s' 'e' 't' _)> */
		func() bool {
			position453, tokenIndex453 := position, tokenIndex
			{
				position454 := position
				if buffer[position] != rune('s') {
					goto l453
				}
				position++
				if buffer[position] != rune('e') {
					goto l453
				}
				position++
				if buffer[position] != rune('t') {
					goto l453
				}
				position++
				if !_rules[rule_]() {
					goto l453
				}
				add(ruleSET, position454)
			}
			return true
		l453:
			position, tokenIndex = position453, tokenIndex453
			return false
		},
		/* 84 CLEAR <- <('c' 'l' 'e' 'a' 'r' _)> */
		func() bool {
			position455, tokenIndex455 := position, tokenIndex
			{
				position456 := position
				if buffer[position] != rune('c') {
					goto l455
				}
				position++
				if buffer[position] != rune('l') {
					goto l455
				}
				position++
				if buffer[position] != rune('e') {
					goto l455
				}
				position++
				if buffer[position] != rune('a') {
					goto l455
				}
				position++
				if buffer[position] != rune('r') {
					goto l455
				}
				position++
				if !_rules[rule_]() {
					goto l455
				}
				add(ruleCLEAR, position456)
			}
			return true
		l455:
			position, tokenIndex = position455, tokenIndex455
			return false
		},
		/* 85 FETCH <- <('f' 'e' 't' 'c' 'h' _)> */
		func() bool {
			position457, tokenIndex457 := position, tokenIndex
			{
				position458 := position
				if buffer[position] != rune('f') {
					goto l457
				}
				position++
				if buffer[position] != rune('e') {
					goto l457
				}
				position++
				if buffer[position] != rune('t') {
					goto l457
				}
				position++
				if buffer[position] != rune('c') {
					goto l457
				}
				position++
				if buffer[position] != rune('h') {
					goto l457
				}
				position++
				if !_rules[rule_]() {
					goto l457
				}
				add(ruleFETCH, position458)
			}
			return true
		l457:
			position, tokenIndex = position457, tokenIndex457
			return false
		},
		/* 86 LIST <- <('l' 'i' 's' 't' _)> */
		func() bool {
			position459, tokenIndex459 := position, tokenIndex
			{
				position460 := position
				if buffer[position] != rune('l') {
					goto l459
				}
				position++
				if buffer[position] != rune('i') {
					goto l459
				}
				position++
				if buffer[position] != rune('s') {
					goto l459
				}
				position++
				if buffer[position] != rune('t') {
					goto l459
				}
				position++
				if !_rules[rule_]() {
					goto l459
				}
				add(ruleLIST, position460)
			}
			return true
		l459:
			position, tokenIndex = position459, tokenIndex459
			return false
		},
		/* 87 EXISTS <- <('e' 'x' 'i' 's' 't' 's' _)> */
		func() bool {
			position461, tokenIndex461 := position, tokenIndex
			{
				position462 := position
				if buffer[position] != rune('e') {
					goto l461
				}
				position++
				if buffer[position] != rune('x') {
					goto l461
				}
				position++
				if buffer[position] != rune('i') {
					goto l461
				}
				position++
				if buffer[position] != rune('s') {
					goto l461
				}
				position++
				if buffer[position] != rune('t') {
					goto l461
				}
				position++
				if buffer[position] != rune('s') {
					goto l461
				}
				position++
				if !_rules[rule_]() {
					goto l461
				}
				add(ruleEXISTS, position462)
			}
			return true
		l461:
			position, tokenIndex = position461, tokenIndex461
			return false
		},
		/* 88 FREE <- <('f' 'r' 'e' 'e' _)> */
		func() bool {
			position463, tokenIndex463 := position, tokenIndex
			{
				position464 := position
				if buffer[position] != rune('f') {
					goto l463
				}
				position++
				if buffer[position] != rune('r') {
					goto l463
				}
				position++
				if buffer[position] != rune('e') {
					goto l463
				}
				position++
				if buffer[position] != rune('e') {
					goto l463
				}
				position++
				if !_rules[rule_]() {
					goto l463
				}
				add(ruleFREE, position464)
			}
			return true
		l463:
			position, tokenIndex = position463, tokenIndex463
			return false
		},
		/* 89 NEST <- <('n' 'e' 's' 't' _)> */
		func() bool {
			position465, tokenIndex465 := position, tokenIndex
			{
				position466 := position
				if buffer[position] != rune('n') {
					goto l465
				}
				position++
				if buffer[position] != rune('e') {
					goto l465
				}
				position++
				if buffer[position] != rune('s') {
					goto l465
				}
				position++
				if buffer[position] != rune('t') {
					goto l465
				}
				position++
				if !_rules[rule_]() {
					goto l465
				}
				add(ruleNEST, position466)
			}
			return true
		l465:
			position, tokenIndex = position465, tokenIndex465
			return false
		},
		/* 90 TRUE <- <('t' 'r' 'u' 'e' _)> */
		nil,
		/* 91 FALSE <- <('f' 'a' 'l' 's' 'e' _)> */
		nil,
		/* 92 EXTERNAL <- <('e' 'x' 't' 'e' 'r' 'n' 'a' 'l')> */
		func() bool {
			position469, tokenIndex469 := position, tokenIndex
			{
				position470 := position
				if buffer[position] != rune('e') {
					goto l469
				}
				position++
				if buffer[position] != rune('x') {
					goto l469
				}
				position++
				if buffer[position] != rune('t') {
					goto l469
				}
				position++
				if buffer[position] != rune('e') {
					goto l469
				}
				position++
				if buffer[position] != rune('r') {
					goto l469
				}
				position++
				if buffer[position] != rune('n') {
					goto l469
				}
				position++
				if buffer[position] != rune('a') {
					goto l469
				}
				position++
				if buffer[position] != rune('l') {
					goto l469
				}
				position++
				add(ruleEXTERNAL, position470)
			}
			return true
		l469:
			position, tokenIndex = position469, tokenIndex469
			return false
		},
		/* 93 NAME <- <('n' 'a' 'm' 'e')> */
		func() bool {
			position471, tokenIndex471 := position, tokenIndex
			{
				position472 := position
				if buffer[position] != rune('n') {
					goto l471
				}
				position++
				if buffer[position] != rune('a') {
					goto l471
				}
				position++
				if buffer[position] != rune('m') {
					goto l471
				}
				position++
				if buffer[position] != rune('e') {
					goto l471
				}
				position++
				add(ruleNAME, position472)
			}
			return true
		l471:
			position, tokenIndex = position471, tokenIndex471
			return false
		},
		/* 94 TYPE <- <('t' 'y' 'p' 'e')> */
		func() bool {
			position473, tokenIndex473 := position, tokenIndex
			{
				position474 := position
				if buffer[position] != rune('t') {
					goto l473
				}
				position++
				if buffer[position] != rune('y') {
					goto l473
				}
				position++
				if buffer[position] != rune('p') {
					goto l473
				}
				position++
				if buffer[position] != rune('e') {
					goto l473
				}
				position++
				add(ruleTYPE, position474)
			}
			return true
		l473:
			position, tokenIndex = position473, tokenIndex473
			return false
		},
		/* 95 VERB <- <('v' 'e' 'r' 'b')> */
		func() bool {
			position475, tokenIndex475 := position, tokenIndex
			{
				position476 := position
				if buffer[position] != rune('v') {
					goto l475
				}
				position++
				if buffer[position] != rune('e') {
					goto l475
				}
				position++
				if buffer[position] != rune('r') {
					goto l475
				}
				position++
				if buffer[position] != rune('b') {
					goto l475
				}
				position++
				add(ruleVERB, position476)
			}
			return true
		l475:
			position, tokenIndex = position475, tokenIndex475
			return false
		},
		/* 96 MECHANISM <- <('m' 'e' 'c' 'h' 'a' 'n' 'i' 's' 'm')> */
		func() bool {
			position477, tokenIndex477 := position, tokenIndex
			{
				position478 := position
				if buffer[position] != rune('m') {
					goto l477
				}
				position++
				if buffer[position] != rune('e') {
					goto l477
				}
				position++
				if buffer[position] != rune('c') {
					goto l477
				}
				position++
				if buffer[position] != rune('h') {
					goto l477
				}
				position++
				if buffer[position] != rune('a') {
					goto l477
				}
				position++
				if buffer[position] != rune('n') {
					goto l477
				}
				position++
				if buffer[position] != rune('i') {
					goto l477
				}
				position++
				if buffer[position] != rune('s') {
					goto l477
				}
				position++
				if buffer[position] != rune('m') {
					goto l477
				}
				position++
				add(ruleMECHANISM, position478)
			}
			return true
		l477:
			position, tokenIndex = position477, tokenIndex477
			return false
		},
		/* 97 ASYNC <- <('a' 's' 'y' 'n' 'c')> */
		func() bool {
			position479, tokenIndex479 := position, tokenIndex
			{
				position480 := position
				if buffer[position] != rune('a') {
					goto l479
				}
				position++
				if buffer[position] != rune('s') {
					goto l479
				}
				position++
				if buffer[position] != rune('y') {
					goto l479
				}
				position++
				if buffer[position] != rune('n') {
					goto l479
				}
				position++
				if buffer[position] != rune('c') {
					goto l479
				}
				position++
				add(ruleASYNC, position480)
			}
			return true
		l479:
			position, tokenIndex = position479, tokenIndex479
			return false
		},
		/* 98 EXPANDED <- <('e' 'x' 'p' 'a' 'n' 'd' 'e' 'd')> */
		func() bool {
			position481, tokenIndex481 := position, tokenIndex
			{
				position482 := position
				if buffer[position] != rune('e') {
					goto l481
				}
				position++
				if buffer[position] != rune('x') {
					goto l481
				}
				position++
				if buffer[position] != rune('p') {
					goto l481
				}
				position++
				if buffer[position] != rune('a') {
					goto l481
				}
				position++
				if buffer[position] != rune('n') {
					goto l481
				}
				position++
				if buffer[position] != rune('d') {
					goto l481
				}
				position++
				if buffer[position] != rune('e') {
					goto l481
				}
				position++
				if buffer[position] != rune('d') {
					goto l481
				}
				position++
				add(ruleEXPANDED, position482)
			}
			return true
		l481:
			position, tokenIndex = position481, tokenIndex481
			return false
		},
		/* 99 VERSION <- <('v' 'e' 'r' 's' 'i' 'o' 'n')> */
		nil,
		/* 100 ID <- <('i' 'd')> */
		nil,
		/* 101 PERSON <- <('p' 'e' 'r' 's' 'o' 'n' _)> */
		nil,
		/* 102 DATABASE <- <('d' 'a' 't' 'a' 'b' 'a' 's' 'e' _)> */
		nil,
		/* 103 QUEUE <- <('q' 'u' 'e' 'u' 'e' _)> */
		nil,
		/* 104 BLOBSTORE <- <('b' 'l' 'o' 'b' 's' 't' 'o' 'r' 'e' _)> */
		nil,
		/* 105 BROWSER <- <('b' 'r' 'o' 'w' 's' 'e' 'r' _)> */
		nil,
		/* 106 MOBILE <- <('m' 'o' 'b' 'i' 'l' 'e' _)> */
		nil,
		/* 107 SERVER <- <('s' 'e' 'r' 'v' 'e' 'r' _)> */
		nil,
		/* 108 DEVICE <- <('d' 'e' 'v' 'i' 'c' 'e' _)> */
		nil,
		/* 109 CODE <- <('c' 'o' 'd' 'e' _)> */
		nil,
		/* 110 DELIMITER <- <('$' '$')> */
		func() bool {
			position494, tokenIndex494 := position, tokenIndex
			{
				position495 := position
				if buffer[position] != rune('$') {
					goto l494
				}
				position++
				if buffer[position] != rune('$') {
					goto l494
				}
				position++
				add(ruleDELIMITER, position495)
			}
			return true
		l494:
			position, tokenIndex = position494, tokenIndex494
			return false
		},
		/* 111 QUOTE <- <'"'> */
		func() bool {
			position496, tokenIndex496 := position, tokenIndex
			{
				position497 := position
				if buffer[position] != rune('"') {
					goto l496
				}
				position++
				add(ruleQUOTE, position497)
			}
			return true
		l496:
			position, tokenIndex = position496, tokenIndex496
			return false
		},
		/* 112 EQUALS <- <'='> */
		func() bool {
			position498, tokenIndex498 := position, tokenIndex
			{
				position499 := position
				if buffer[position] != rune('=') {
					goto l498
				}
				position++
				add(ruleEQUALS, position499)
			}
			return true
		l498:
			position, tokenIndex = position498, tokenIndex498
			return false
		},
		/* 113 FLAG <- <('-' '-'?)> */
		func() bool {
			position500, tokenIndex500 := position, tokenIndex
			{
				position501 := position
				if buffer[position] != rune('-') {
					goto l500
				}
				position++
				{
					position502, tokenIndex502 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l502
					}
					position++
					goto l503
				l502:
					position, tokenIndex = position502, tokenIndex502
				}
			l503:
				add(ruleFLAG, position501)
			}
			return true
		l500:
			position, tokenIndex = position500, tokenIndex500
			return false
		},
		/* 114 STRICT <- <('s' 't' 'r' 'i' 'c' 't' _)> */
		nil,
		/* 115 VERBOSE <- <('v' 'e' 'r' 'b' 'o' 's' 'e' _)> */
		nil,
		/* 116 IDS <- <('i' 'd' 's' _)> */
		nil,
		/* 117 _ <- <Whitespace*> */
		func() bool {
			{
				position508 := position
			l509:
				{
					position510, tokenIndex510 := position, tokenIndex
					{
						position511 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l510
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l510
								}
								position++
							default:
								{
									position513 := position
									{
										position514, tokenIndex514 := position, tokenIndex
										if buffer[position] != rune('\r') {
											goto l515
										}
										position++
										if buffer[position] != rune('\n') {
											goto l515
										}
										position++
										goto l514
									l515:
										position, tokenIndex = position514, tokenIndex514
										if buffer[position] != rune('\n') {
											goto l516
										}
										position++
										goto l514
									l516:
										position, tokenIndex = position514, tokenIndex514
										if buffer[position] != rune('\r') {
											goto l510
										}
										position++
									}
								l514:
									add(ruleEOL, position513)
								}
							}
						}

						add(ruleWhitespace, position511)
					}
					goto l509
				l510:
					position, tokenIndex = position510, tokenIndex510
				}
				add(rule_, position508)
			}
			return true
		},
		/* 118 Whitespace <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EOL))> */
		nil,
		/* 119 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		nil,
		/* 120 END <- <!.> */
		func() bool {
			position519, tokenIndex519 := position, tokenIndex
			{
				position520 := position
				{
					position521, tokenIndex521 := position, tokenIndex
					if !matchDot() {
						goto l521
					}
					goto l519
				l521:
					position, tokenIndex = position521, tokenIndex521
				}
				add(ruleEND, position520)
			}
			return true
		l519:
			position, tokenIndex = position519, tokenIndex519
			return false
		},
		/* 122 Action0 <- <{
		   p.StmtType = "Response"
		 }> */
		nil,
		/* 123 Action1 <- <{
		   p.StmtType = "Command"
		   p.InputAttributes.Raw = p.Buffer
		 }> */
		nil,
		nil,
		/* 125 Action2 <- <{ p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text)) }> */
		nil,
		/* 126 Action3 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 127 Action4 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 128 Action5 <- <{ p.InputAttributes.Verb = "create-or-fetch" }> */
		nil,
		/* 129 Action6 <- <{ p.InputAttributes.Verb = "create-or-set" }> */
		nil,
		/* 130 Action7 <- <{
		   p.StmtType = "WorldObject"; p.Response.Object.Type = "world"
		   p.Response.Object.Repr = strings.Join(append([]string{p.WorldParams["paramString"], p.TreeString}, p.RelStrings...), "\n")
		 }> */
		nil,
		/* 131 Action8 <- <{
		   p.Response.Object.Type = "item"; p.Response.Object.Repr = strings.TrimSpace(text); p.ItemStrings = append(p.ItemStrings, strings.TrimSpace(text))
		   p.currentId = p.InputAttributes.ResourceId
		   p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})
		 }> */
		nil,
		/* 132 Action9 <- <{ p.Response.Object.Type = "rel"; p.Response.Object.Repr = strings.TrimSpace(text); p.RelStrings = append(p.RelStrings, strings.TrimSpace(text)) }> */
		nil,
		/* 133 Action10 <- <{ p.Response.Object.Type = "ids"; b, _ := json.Marshal(p.InputAttributes.ResourceIds); p.Response.Object.Repr = string(b) }> */
		nil,
		/* 134 Action11 <- <{
		   p.StmtType = "Tree"; p.Response.Object.Type = "tree"; p.Response.Object.Repr = text; p.TreeString = text
		   if len(p.nodeStack) > 0 {
		     node := p.nodeStack[len(p.nodeStack)-1]
		     p.nodeStack = p.nodeStack[:len(p.nodeStack)-1]
		     if len(p.nodeStack) > 0 {
		       p.nodeStack[len(p.nodeStack)-1].Children = append(p.nodeStack[len(p.nodeStack)-1].Children, node)
		     } else {
		       p.Tree = node
		     }
		   }
		 }> */
		nil,
		/* 135 Action12 <- <{
		   p.currentId = "nil"
		   p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})
		 }> */
		nil,
		/* 136 Action13 <- <{
		   p.StmtType = "Status"
		   p.Response.Status.Message = cleanString(text)
		 }> */
		nil,
		/* 137 Action14 <- <{ p.Response.Status.Code = p.number }> */
		nil,
		/* 138 Action15 <- <{ p.InputAttributes.Params["limit"] = cleanString(text) }> */
		nil,
		/* 139 Action16 <- <{ p.InputAttributes.ResourceId = cleanString(text) }> */
		nil,
		/* 140 Action17 <- <{
		   p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		 }> */
		nil,
		/* 141 Action18 <- <{
		   p.InputAttributes.ResourceId = ""
		   ids := strings.Fields(text)
		   for _, id := range ids {
		     p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
		   }
		 }> */
		nil,
		/* 142 Action19 <- <{
		   p.WorldParams["paramString"] = fmt.Sprintf("version=%s\nid=%s\nname=%s\nexpanded=%s", p.WorldParams["version"], p.WorldParams["id"], p.WorldParams["name"], p.WorldParams["expanded"])
		 }> */
		nil,
		/* 143 Action20 <- <{ p.WorldParams["version"] = cleanString(text) }> */
		nil,
		/* 144 Action21 <- <{ p.WorldParams["id"] = cleanString(text) }> */
		nil,
		/* 145 Action22 <- <{ p.WorldParams["name"] = strings.TrimSpace(text) }> */
		nil,
		/* 146 Action23 <- <{ p.WorldParams["expanded"] = strings.TrimSpace(text) }> */
		nil,
		/* 147 Action24 <- <{ p.Params["external"] = cleanString(text) }> */
		nil,
		/* 148 Action25 <- <{ p.Params["type"] = cleanString(text) }> */
		nil,
		/* 149 Action26 <- <{ p.Params["name"] = cleanString(text) }> */
		nil,
		/* 150 Action27 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 151 Action28 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 152 Action29 <- <{ p.Params["verb"] = cleanString(text) }> */
		nil,
		/* 153 Action30 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 154 Action31 <- <{ p.Params["async"] = cleanString(text) }> */
		nil,
		/* 155 Action32 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 156 Action33 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 157 Action34 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 158 Action35 <- <{ p.text = cleanString(text) }> */
		nil,
		/* 159 Action36 <- <{ n, _ := strconv.Atoi(text); p.number = n }> */
		nil,
		/* 160 Action37 <- <{ p.bool = text == "true" }> */
		nil,
		/* 161 Action38 <- <{ p.InputAttributes.ResourceType = "item"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 162 Action39 <- <{ p.InputAttributes.ResourceType = "rel"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 163 Action40 <- <{ p.InputAttributes.ResourceType = "world" }> */
		nil,
		/* 164 Action41 <- <{ p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 165 Action42 <- <{ p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 166 Action43 <- <{ p.InputAttributes.Verb = "create" }> */
		nil,
		/* 167 Action44 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 168 Action45 <- <{ p.InputAttributes.Verb = "set" }> */
		nil,
		/* 169 Action46 <- <{ p.InputAttributes.Verb = "clear" }> */
		nil,
		/* 170 Action47 <- <{ p.InputAttributes.Verb = "delete" }> */
		nil,
		/* 171 Action48 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 172 Action49 <- <{ p.InputAttributes.Verb = "nest"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 173 Action50 <- <{ p.InputAttributes.Verb = "free"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 174 Action51 <- <{ p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 175 Action52 <- <{ p.InputAttributes.Verb = "in?"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 176 Action53 <- <{ p.InputAttributes.Verb = "from?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 177 Action54 <- <{ p.InputAttributes.Verb = "to?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 178 Action55 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict") }> */
		nil,
		/* 179 Action56 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose") }> */
		nil,
		/* 180 Action57 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids") }> */
		nil,
	}
	p.rules = _rules
	return nil
}
