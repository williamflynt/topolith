package grammar

// Code generated by peg -inline -switch -strict -output pkg/grammar/grammar.peg.go pkg/grammar/grammar.peg DO NOT EDIT.

import (
	"encoding/json"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleValid
	ruleResponse
	ruleCommand
	ruleMutation
	ruleTreeMutation
	ruleQuery
	ruleFetchQuery
	ruleListQuery
	ruleExistsQuery
	ruleStateBound
	ruleCreateOrFetch
	ruleCreateOrSet
	ruleObjects
	ruleWorldObject
	ruleItemObject
	ruleRelObject
	ruleIdentifierListObject
	ruleTree
	ruleNil
	ruleErrorOrOkay
	ruleErrCode
	ruleLimit
	ruleIdentifier
	ruleSecondIdentifier
	ruleDualIdentifier
	ruleIdentifierList
	ruleWorldParams
	ruleItemParams
	ruleRelParams
	ruleWorldParamVersion
	ruleWorldParamId
	ruleWorldParamName
	ruleWorldParamExpanded
	ruleItemParam
	ruleRelParam
	ruleItemKeys
	ruleRelKeys
	ruleItemKey
	ruleRelKey
	ruleStringLike
	ruleNumber
	ruleBoolean
	ruleText
	ruleQuotedText
	ruleItemExists
	ruleRelExists
	ruleWorld
	ruleItem
	ruleRel
	ruleCreate
	ruleFetch
	ruleSet
	ruleClear
	ruleDelete
	ruleList
	ruleNest
	ruleFree
	ruleExists
	ruleInQuery
	ruleFromQuery
	ruleToQuery
	ruleFlag
	ruleStrictFlag
	ruleVerboseFlag
	ruleIdsFlag
	ruleBeginWorld
	ruleEndWorld
	ruleItemType
	ruleKeyword
	ruleWORLD
	ruleENDWORLD
	ruleERROR
	ruleOK
	ruleITEM
	ruleITEM_EXISTS
	ruleREL
	ruleREL_EXISTS
	ruleFROM_QUERY
	ruleTO_QUERY
	ruleIN
	ruleIN_QUERY
	ruleCREATE
	ruleDELETE
	ruleSET
	ruleCLEAR
	ruleFETCH
	ruleLIST
	ruleEXISTS
	ruleFREE
	ruleNEST
	ruleTRUE
	ruleFALSE
	ruleEXTERNAL
	ruleNAME
	ruleTYPE
	ruleVERB
	ruleMECHANISM
	ruleASYNC
	ruleEXPANDED
	ruleVERSION
	ruleID
	rulePERSON
	ruleDATABASE
	ruleQUEUE
	ruleBLOBSTORE
	ruleBROWSER
	ruleMOBILE
	ruleSERVER
	ruleDEVICE
	ruleCODE
	ruleDELIMITER
	ruleQUOTE
	ruleEQUALS
	ruleFLAG
	ruleSTRICT
	ruleVERBOSE
	ruleIDS
	rule_
	ruleWhitespace
	ruleEOL
	ruleEND
	ruleAction0
	ruleAction1
	rulePegText
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
)

var rul3s = [...]string{
	"Unknown",
	"Valid",
	"Response",
	"Command",
	"Mutation",
	"TreeMutation",
	"Query",
	"FetchQuery",
	"ListQuery",
	"ExistsQuery",
	"StateBound",
	"CreateOrFetch",
	"CreateOrSet",
	"Objects",
	"WorldObject",
	"ItemObject",
	"RelObject",
	"IdentifierListObject",
	"Tree",
	"Nil",
	"ErrorOrOkay",
	"ErrCode",
	"Limit",
	"Identifier",
	"SecondIdentifier",
	"DualIdentifier",
	"IdentifierList",
	"WorldParams",
	"ItemParams",
	"RelParams",
	"WorldParamVersion",
	"WorldParamId",
	"WorldParamName",
	"WorldParamExpanded",
	"ItemParam",
	"RelParam",
	"ItemKeys",
	"RelKeys",
	"ItemKey",
	"RelKey",
	"StringLike",
	"Number",
	"Boolean",
	"Text",
	"QuotedText",
	"ItemExists",
	"RelExists",
	"World",
	"Item",
	"Rel",
	"Create",
	"Fetch",
	"Set",
	"Clear",
	"Delete",
	"List",
	"Nest",
	"Free",
	"Exists",
	"InQuery",
	"FromQuery",
	"ToQuery",
	"Flag",
	"StrictFlag",
	"VerboseFlag",
	"IdsFlag",
	"BeginWorld",
	"EndWorld",
	"ItemType",
	"Keyword",
	"WORLD",
	"ENDWORLD",
	"ERROR",
	"OK",
	"ITEM",
	"ITEM_EXISTS",
	"REL",
	"REL_EXISTS",
	"FROM_QUERY",
	"TO_QUERY",
	"IN",
	"IN_QUERY",
	"CREATE",
	"DELETE",
	"SET",
	"CLEAR",
	"FETCH",
	"LIST",
	"EXISTS",
	"FREE",
	"NEST",
	"TRUE",
	"FALSE",
	"EXTERNAL",
	"NAME",
	"TYPE",
	"VERB",
	"MECHANISM",
	"ASYNC",
	"EXPANDED",
	"VERSION",
	"ID",
	"PERSON",
	"DATABASE",
	"QUEUE",
	"BLOBSTORE",
	"BROWSER",
	"MOBILE",
	"SERVER",
	"DEVICE",
	"CODE",
	"DELIMITER",
	"QUOTE",
	"EQUALS",
	"FLAG",
	"STRICT",
	"VERBOSE",
	"IDS",
	"_",
	"Whitespace",
	"EOL",
	"END",
	"Action0",
	"Action1",
	"PegText",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Parser struct {
	StmtType string
	InputAttributes
	Response

	text   string // Text parsed by the StringLike rule.
	number int    // Number parsed by the Number rule.
	bool   bool   // Boolean parsed by the Boolean rule.

	Tree        Node     // The root of the world.Tree.
	TreeString  string   // Track the string representation of the Tree parsed by the Tree rule.
	ItemStrings []string // Track the string representations of Items parsed by the ItemObject rule.
	RelStrings  []string // Track the string representations of Rels parsed by the RelObject rule.

	// For building the tree.
	currentId string // Current Identifier being parsed.
	nodeStack []Node // Stack of nodes for building the tree.

	// For parsing World.
	WorldParams map[string]string

	Buffer string
	buffer []rune
	rules  [181]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *Parser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Parser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Parser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Parser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Parser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Parser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *Parser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:

			p.StmtType = "Response"

		case ruleAction1:

			p.StmtType = "Command"
			p.InputAttributes.Raw = p.Buffer

		case ruleAction2:
			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		case ruleAction3:
			p.InputAttributes.Verb = "fetch"
		case ruleAction4:
			p.InputAttributes.Verb = "list"
		case ruleAction5:
			p.InputAttributes.Verb = "create-or-fetch"
		case ruleAction6:
			p.InputAttributes.Verb = "create-or-set"
		case ruleAction7:

			p.Response.Object.Type = "world"
			p.Response.Object.Repr = strings.Join(append([]string{p.WorldParams["paramString"], p.TreeString}, p.RelStrings...), "\n")

		case ruleAction8:

			p.Response.Object.Type = "item"
			p.Response.Object.Repr = cleanString(text)
			p.ItemStrings = append(p.ItemStrings, strings.TrimSpace(text))
			p.currentId = p.InputAttributes.ResourceId
			p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})

		case ruleAction9:
			p.Response.Object.Type = "rel"
			p.Response.Object.Repr = cleanString(text)
			p.RelStrings = append(p.RelStrings, strings.TrimSpace(text))
		case ruleAction10:
			p.Response.Object.Type = "ids"
			b, _ := json.Marshal(p.InputAttributes.ResourceIds)
			p.Response.Object.Repr = string(b)
		case ruleAction11:

			p.StmtType = "Tree"
			p.Response.Object.Type = "tree"
			p.Response.Object.Repr = text
			p.TreeString = text
			if len(p.nodeStack) > 0 {
				node := p.nodeStack[len(p.nodeStack)-1]
				p.nodeStack = p.nodeStack[:len(p.nodeStack)-1]
				if len(p.nodeStack) > 0 {
					p.nodeStack[len(p.nodeStack)-1].Children = append(p.nodeStack[len(p.nodeStack)-1].Children, node)
				} else {
					p.Tree = node
				}
			}

		case ruleAction12:

			p.currentId = "nil"
			p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})

		case ruleAction13:

			p.Response.Status.Message = cleanString(text)

		case ruleAction14:
			p.Response.Status.Code = p.number
		case ruleAction15:
			p.InputAttributes.Params["limit"] = cleanString(text)
		case ruleAction16:
			p.InputAttributes.ResourceId = cleanString(text)
		case ruleAction17:

			p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))

		case ruleAction18:

			p.InputAttributes.ResourceId = ""
			ids := strings.Fields(text)
			for _, id := range ids {
				p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
			}

		case ruleAction19:

			p.WorldParams["paramString"] = fmt.Sprintf("version=%s\nid=%s\nname=%s\nexpanded=%s", p.WorldParams["version"], p.WorldParams["id"], p.WorldParams["name"], p.WorldParams["expanded"])

		case ruleAction20:
			p.WorldParams["version"] = cleanString(text)
		case ruleAction21:
			p.WorldParams["id"] = strings.TrimSpace(text)
		case ruleAction22:
			p.WorldParams["name"] = strings.TrimSpace(text)
		case ruleAction23:
			p.WorldParams["expanded"] = strings.TrimSpace(text)
		case ruleAction24:
			p.Params["external"] = cleanString(text)
		case ruleAction25:
			p.Params["type"] = cleanString(text)
		case ruleAction26:
			p.Params["name"] = cleanString(text)
		case ruleAction27:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction28:
			p.Params["expanded"] = cleanString(text)
		case ruleAction29:
			p.Params["verb"] = cleanString(text)
		case ruleAction30:
			p.Params["mechanism"] = cleanString(text)
		case ruleAction31:
			p.Params["async"] = cleanString(text)
		case ruleAction32:
			p.Params["expanded"] = cleanString(text)
		case ruleAction33:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction34:
			p.InputAttributes.Params[cleanString(text)] = ""
		case ruleAction35:
			p.text = cleanString(text)
		case ruleAction36:
			n, _ := strconv.Atoi(text)
			p.number = n
		case ruleAction37:
			p.bool = text == "true"
		case ruleAction38:
			p.InputAttributes.ResourceType = "item"
			p.InputAttributes.Verb = "exists"
		case ruleAction39:
			p.InputAttributes.ResourceType = "rel"
			p.InputAttributes.Verb = "exists"
		case ruleAction40:
			p.InputAttributes.ResourceType = "world"
		case ruleAction41:
			p.InputAttributes.ResourceType = "item"
		case ruleAction42:
			p.InputAttributes.ResourceType = "rel"
		case ruleAction43:
			p.InputAttributes.Verb = "create"
		case ruleAction44:
			p.InputAttributes.Verb = "fetch"
		case ruleAction45:
			p.InputAttributes.Verb = "set"
		case ruleAction46:
			p.InputAttributes.Verb = "clear"
		case ruleAction47:
			p.InputAttributes.Verb = "delete"
		case ruleAction48:
			p.InputAttributes.Verb = "list"
		case ruleAction49:
			p.InputAttributes.Verb = "nest"
			p.InputAttributes.ResourceType = "item"
		case ruleAction50:
			p.InputAttributes.Verb = "free"
			p.InputAttributes.ResourceType = "item"
		case ruleAction51:
			p.InputAttributes.Verb = "exists"
		case ruleAction52:
			p.InputAttributes.Verb = "in?"
			p.InputAttributes.ResourceType = "item"
		case ruleAction53:
			p.InputAttributes.Verb = "from?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction54:
			p.InputAttributes.Verb = "to?"
			p.InputAttributes.ResourceType = "rel"
		case ruleAction55:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict")
		case ruleAction56:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose")
		case ruleAction57:
			p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids")

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Parser) error {
	return func(p *Parser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Parser) error {
	return func(p *Parser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *Parser) Init(options ...func(*Parser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Valid <- <(Command / Response / WorldObject / Tree)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4 := position
						if !_rules[rule_]() {
							goto l3
						}
						{
							position5, tokenIndex5 := position, tokenIndex
							{
								position7 := position
								{
									position8, tokenIndex8 := position, tokenIndex
									if !_rules[ruleItem]() {
										goto l9
									}
									{
										position10, tokenIndex10 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l11
										}
										goto l10
									l11:
										position, tokenIndex = position10, tokenIndex10
										if !_rules[ruleSet]() {
											goto l9
										}
									}
								l10:
									if !_rules[ruleIdentifier]() {
										goto l9
									}
									{
										position12, tokenIndex12 := position, tokenIndex
										if !_rules[ruleItemParams]() {
											goto l12
										}
										goto l13
									l12:
										position, tokenIndex = position12, tokenIndex12
									}
								l13:
									goto l8
								l9:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l14
									}
									if !_rules[ruleClear]() {
										goto l14
									}
									if !_rules[ruleIdentifier]() {
										goto l14
									}
									{
										position15 := position
										{
											position18 := position
											{
												position19 := position
												{
													position20, tokenIndex20 := position, tokenIndex
													if !_rules[ruleEXTERNAL]() {
														goto l21
													}
													goto l20
												l21:
													position, tokenIndex = position20, tokenIndex20
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l14
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l14
															}
														case 't':
															if !_rules[ruleTYPE]() {
																goto l14
															}
														default:
															if !_rules[ruleNAME]() {
																goto l14
															}
														}
													}

												}
											l20:
												add(rulePegText, position19)
											}
											if !_rules[rule_]() {
												goto l14
											}
											{
												add(ruleAction33, position)
											}
											add(ruleItemKey, position18)
										}
									l16:
										{
											position17, tokenIndex17 := position, tokenIndex
											{
												position24 := position
												{
													position25 := position
													{
														position26, tokenIndex26 := position, tokenIndex
														if !_rules[ruleEXTERNAL]() {
															goto l27
														}
														goto l26
													l27:
														position, tokenIndex = position26, tokenIndex26
														{
															switch buffer[position] {
															case 'e':
																if !_rules[ruleEXPANDED]() {
																	goto l17
																}
															case 'm':
																if !_rules[ruleMECHANISM]() {
																	goto l17
																}
															case 't':
																if !_rules[ruleTYPE]() {
																	goto l17
																}
															default:
																if !_rules[ruleNAME]() {
																	goto l17
																}
															}
														}

													}
												l26:
													add(rulePegText, position25)
												}
												if !_rules[rule_]() {
													goto l17
												}
												{
													add(ruleAction33, position)
												}
												add(ruleItemKey, position24)
											}
											goto l16
										l17:
											position, tokenIndex = position17, tokenIndex17
										}
										add(ruleItemKeys, position15)
									}
									goto l8
								l14:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleItem]() {
										goto l30
									}
									if !_rules[ruleDelete]() {
										goto l30
									}
									if !_rules[ruleIdentifier]() {
										goto l30
									}
									goto l8
								l30:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l31
									}
									{
										position32, tokenIndex32 := position, tokenIndex
										if !_rules[ruleCreate]() {
											goto l33
										}
										goto l32
									l33:
										position, tokenIndex = position32, tokenIndex32
										if !_rules[ruleSet]() {
											goto l31
										}
									}
								l32:
									if !_rules[ruleDualIdentifier]() {
										goto l31
									}
									{
										position34, tokenIndex34 := position, tokenIndex
										if !_rules[ruleRelParams]() {
											goto l34
										}
										goto l35
									l34:
										position, tokenIndex = position34, tokenIndex34
									}
								l35:
									goto l8
								l31:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l36
									}
									if !_rules[ruleClear]() {
										goto l36
									}
									if !_rules[ruleDualIdentifier]() {
										goto l36
									}
									{
										position37 := position
										{
											position40 := position
											{
												position41 := position
												{
													switch buffer[position] {
													case 'e':
														if !_rules[ruleEXPANDED]() {
															goto l36
														}
													case 'a':
														if !_rules[ruleASYNC]() {
															goto l36
														}
													case 'm':
														if !_rules[ruleMECHANISM]() {
															goto l36
														}
													default:
														if !_rules[ruleVERB]() {
															goto l36
														}
													}
												}

												add(rulePegText, position41)
											}
											if !_rules[rule_]() {
												goto l36
											}
											{
												add(ruleAction34, position)
											}
											add(ruleRelKey, position40)
										}
									l38:
										{
											position39, tokenIndex39 := position, tokenIndex
											{
												position44 := position
												{
													position45 := position
													{
														switch buffer[position] {
														case 'e':
															if !_rules[ruleEXPANDED]() {
																goto l39
															}
														case 'a':
															if !_rules[ruleASYNC]() {
																goto l39
															}
														case 'm':
															if !_rules[ruleMECHANISM]() {
																goto l39
															}
														default:
															if !_rules[ruleVERB]() {
																goto l39
															}
														}
													}

													add(rulePegText, position45)
												}
												if !_rules[rule_]() {
													goto l39
												}
												{
													add(ruleAction34, position)
												}
												add(ruleRelKey, position44)
											}
											goto l38
										l39:
											position, tokenIndex = position39, tokenIndex39
										}
										add(ruleRelKeys, position37)
									}
									goto l8
								l36:
									position, tokenIndex = position8, tokenIndex8
									if !_rules[ruleRel]() {
										goto l6
									}
									if !_rules[ruleDelete]() {
										goto l6
									}
									if !_rules[ruleDualIdentifier]() {
										goto l6
									}
								}
							l8:
								add(ruleMutation, position7)
							}
							goto l5
						l6:
							position, tokenIndex = position5, tokenIndex5
							{
								position49 := position
								{
									position50, tokenIndex50 := position, tokenIndex
									{
										position52 := position
										if !_rules[ruleFREE]() {
											goto l51
										}
										{
											add(ruleAction50, position)
										}
										add(ruleFree, position52)
									}
									if !_rules[ruleIdentifierList]() {
										goto l51
									}
									goto l50
								l51:
									position, tokenIndex = position50, tokenIndex50
									{
										position54 := position
										if !_rules[ruleNEST]() {
											goto l48
										}
										{
											add(ruleAction49, position)
										}
										add(ruleNest, position54)
									}
									if !_rules[ruleIdentifierList]() {
										goto l48
									}
									if !_rules[rule_]() {
										goto l48
									}
									if !_rules[ruleIN]() {
										goto l48
									}
									{
										position56 := position
										if !_rules[ruleStringLike]() {
											goto l48
										}
										add(rulePegText, position56)
									}
									{
										add(ruleAction2, position)
									}
								}
							l50:
								add(ruleTreeMutation, position49)
							}
							goto l5
						l48:
							position, tokenIndex = position5, tokenIndex5
							{
								position59 := position
								{
									position60, tokenIndex60 := position, tokenIndex
									{
										position62 := position
										{
											switch buffer[position] {
											case 'w':
												{
													position64 := position
													if !_rules[ruleWORLD]() {
														goto l61
													}
													{
														add(ruleAction40, position)
													}
													add(ruleWorld, position64)
												}
												{
													add(ruleAction3, position)
												}
											case 'r':
												if !_rules[ruleRel]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleDualIdentifier]() {
													goto l61
												}
											default:
												if !_rules[ruleItem]() {
													goto l61
												}
												if !_rules[ruleFetch]() {
													goto l61
												}
												if !_rules[ruleIdentifier]() {
													goto l61
												}
											}
										}

										add(ruleFetchQuery, position62)
									}
									goto l60
								l61:
									position, tokenIndex = position60, tokenIndex60
									{
										position68 := position
										{
											position69, tokenIndex69 := position, tokenIndex
											{
												position71, tokenIndex71 := position, tokenIndex
												if !_rules[ruleItem]() {
													goto l72
												}
												goto l71
											l72:
												position, tokenIndex = position71, tokenIndex71
												if !_rules[ruleRel]() {
													goto l70
												}
											}
										l71:
											{
												position73 := position
												if !_rules[ruleLIST]() {
													goto l70
												}
												{
													add(ruleAction48, position)
												}
												add(ruleList, position73)
											}
											{
												position75, tokenIndex75 := position, tokenIndex
												{
													position77 := position
													{
														position78 := position
														if !_rules[ruleNumber]() {
															goto l75
														}
														add(rulePegText, position78)
													}
													{
														add(ruleAction15, position)
													}
													add(ruleLimit, position77)
												}
												goto l76
											l75:
												position, tokenIndex = position75, tokenIndex75
											}
										l76:
											goto l69
										l70:
											position, tokenIndex = position69, tokenIndex69
											{
												switch buffer[position] {
												case 'f':
													{
														position81 := position
														if !_rules[ruleFROM_QUERY]() {
															goto l67
														}
														{
															add(ruleAction53, position)
														}
														add(ruleFromQuery, position81)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												case 't':
													{
														position83 := position
														if !_rules[ruleTO_QUERY]() {
															goto l67
														}
														{
															add(ruleAction54, position)
														}
														add(ruleToQuery, position83)
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
												default:
													if !_rules[ruleItem]() {
														goto l67
													}
													if !_rules[ruleIN]() {
														goto l67
													}
													if !_rules[ruleIdentifier]() {
														goto l67
													}
													{
														add(ruleAction4, position)
													}
												}
											}

										}
									l69:
										add(ruleListQuery, position68)
									}
									goto l60
								l67:
									position, tokenIndex = position60, tokenIndex60
									{
										position86 := position
										{
											position87, tokenIndex87 := position, tokenIndex
											{
												position89 := position
												if !_rules[ruleIN_QUERY]() {
													goto l88
												}
												{
													add(ruleAction52, position)
												}
												add(ruleInQuery, position89)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l88
											}
											goto l87
										l88:
											position, tokenIndex = position87, tokenIndex87
											{
												position92 := position
												{
													position93, tokenIndex93 := position, tokenIndex
													if !_rules[ruleITEM_EXISTS]() {
														goto l94
													}
													goto l93
												l94:
													position, tokenIndex = position93, tokenIndex93
													if !_rules[ruleItem]() {
														goto l91
													}
													if !_rules[ruleExists]() {
														goto l91
													}
												}
											l93:
												{
													add(ruleAction38, position)
												}
												add(ruleItemExists, position92)
											}
											if !_rules[ruleIdentifier]() {
												goto l91
											}
											goto l87
										l91:
											position, tokenIndex = position87, tokenIndex87
											{
												position96 := position
												{
													position97, tokenIndex97 := position, tokenIndex
													if !_rules[ruleREL_EXISTS]() {
														goto l98
													}
													goto l97
												l98:
													position, tokenIndex = position97, tokenIndex97
													if !_rules[ruleRel]() {
														goto l58
													}
													if !_rules[ruleExists]() {
														goto l58
													}
												}
											l97:
												{
													add(ruleAction39, position)
												}
												add(ruleRelExists, position96)
											}
											if !_rules[ruleDualIdentifier]() {
												goto l58
											}
										}
									l87:
										add(ruleExistsQuery, position86)
									}
								}
							l60:
								add(ruleQuery, position59)
							}
							goto l5
						l58:
							position, tokenIndex = position5, tokenIndex5
							{
								position100 := position
								{
									position101, tokenIndex101 := position, tokenIndex
									{
										position103 := position
										{
											position104, tokenIndex104 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l105
											}
											if !_rules[ruleIdentifier]() {
												goto l105
											}
											{
												position106, tokenIndex106 := position, tokenIndex
												if !_rules[ruleItemParams]() {
													goto l106
												}
												goto l105
											l106:
												position, tokenIndex = position106, tokenIndex106
											}
											goto l104
										l105:
											position, tokenIndex = position104, tokenIndex104
											if !_rules[ruleRel]() {
												goto l102
											}
											if !_rules[ruleDualIdentifier]() {
												goto l102
											}
											{
												position107, tokenIndex107 := position, tokenIndex
												if !_rules[ruleRelParams]() {
													goto l107
												}
												goto l102
											l107:
												position, tokenIndex = position107, tokenIndex107
											}
										}
									l104:
										add(ruleCreateOrFetch, position103)
									}
									{
										add(ruleAction5, position)
									}
									goto l101
								l102:
									position, tokenIndex = position101, tokenIndex101
									{
										position109 := position
										{
											position110, tokenIndex110 := position, tokenIndex
											if !_rules[ruleItem]() {
												goto l111
											}
											if !_rules[ruleIdentifier]() {
												goto l111
											}
											if !_rules[ruleItemParams]() {
												goto l111
											}
											goto l110
										l111:
											position, tokenIndex = position110, tokenIndex110
											if !_rules[ruleRel]() {
												goto l3
											}
											if !_rules[ruleDualIdentifier]() {
												goto l3
											}
											if !_rules[ruleRelParams]() {
												goto l3
											}
										}
									l110:
										add(ruleCreateOrSet, position109)
									}
									{
										add(ruleAction6, position)
									}
								}
							l101:
								add(ruleStateBound, position100)
							}
						}
					l5:
					l113:
						{
							position114, tokenIndex114 := position, tokenIndex
							{
								position115 := position
								{
									position116, tokenIndex116 := position, tokenIndex
									{
										position118 := position
										if !_rules[ruleFLAG]() {
											goto l117
										}
										{
											position119 := position
											if buffer[position] != rune('s') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if buffer[position] != rune('r') {
												goto l117
											}
											position++
											if buffer[position] != rune('i') {
												goto l117
											}
											position++
											if buffer[position] != rune('c') {
												goto l117
											}
											position++
											if buffer[position] != rune('t') {
												goto l117
											}
											position++
											if !_rules[rule_]() {
												goto l117
											}
											add(ruleSTRICT, position119)
										}
										{
											add(ruleAction55, position)
										}
										add(ruleStrictFlag, position118)
									}
									goto l116
								l117:
									position, tokenIndex = position116, tokenIndex116
									{
										position122 := position
										if !_rules[ruleFLAG]() {
											goto l121
										}
										{
											position123 := position
											if buffer[position] != rune('v') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if buffer[position] != rune('r') {
												goto l121
											}
											position++
											if buffer[position] != rune('b') {
												goto l121
											}
											position++
											if buffer[position] != rune('o') {
												goto l121
											}
											position++
											if buffer[position] != rune('s') {
												goto l121
											}
											position++
											if buffer[position] != rune('e') {
												goto l121
											}
											position++
											if !_rules[rule_]() {
												goto l121
											}
											add(ruleVERBOSE, position123)
										}
										{
											add(ruleAction56, position)
										}
										add(ruleVerboseFlag, position122)
									}
									goto l116
								l121:
									position, tokenIndex = position116, tokenIndex116
									{
										position125 := position
										if !_rules[ruleFLAG]() {
											goto l114
										}
										{
											position126 := position
											if buffer[position] != rune('i') {
												goto l114
											}
											position++
											if buffer[position] != rune('d') {
												goto l114
											}
											position++
											if buffer[position] != rune('s') {
												goto l114
											}
											position++
											if !_rules[rule_]() {
												goto l114
											}
											add(ruleIDS, position126)
										}
										{
											add(ruleAction57, position)
										}
										add(ruleIdsFlag, position125)
									}
								}
							l116:
								add(ruleFlag, position115)
							}
							goto l113
						l114:
							position, tokenIndex = position114, tokenIndex114
						}
						if !_rules[ruleEND]() {
							goto l3
						}
						{
							add(ruleAction1, position)
						}
						add(ruleCommand, position4)
					}
					goto l2
				l3:
					position, tokenIndex = position2, tokenIndex2
					{
						position130 := position
						{
							position131, tokenIndex131 := position, tokenIndex
							{
								position133 := position
								{
									position134, tokenIndex134 := position, tokenIndex
									if !_rules[ruleWorldObject]() {
										goto l135
									}
									goto l134
								l135:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleTree]() {
										goto l136
									}
									goto l134
								l136:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleItemObject]() {
										goto l137
									}
								l138:
									{
										position139, tokenIndex139 := position, tokenIndex
										if !_rules[ruleItemObject]() {
											goto l139
										}
										goto l138
									l139:
										position, tokenIndex = position139, tokenIndex139
									}
									goto l134
								l137:
									position, tokenIndex = position134, tokenIndex134
									if !_rules[ruleRelObject]() {
										goto l140
									}
								l141:
									{
										position142, tokenIndex142 := position, tokenIndex
										if !_rules[ruleRelObject]() {
											goto l142
										}
										goto l141
									l142:
										position, tokenIndex = position142, tokenIndex142
									}
									goto l134
								l140:
									position, tokenIndex = position134, tokenIndex134
									{
										position143 := position
										if !_rules[ruleIdentifierList]() {
											goto l131
										}
										{
											add(ruleAction10, position)
										}
										add(ruleIdentifierListObject, position143)
									}
								}
							l134:
								add(ruleObjects, position133)
							}
							goto l132
						l131:
							position, tokenIndex = position131, tokenIndex131
						}
					l132:
						if !_rules[rule_]() {
							goto l129
						}
						if !_rules[ruleDELIMITER]() {
							goto l129
						}
						if !_rules[ruleDELIMITER]() {
							goto l129
						}
						if !_rules[rule_]() {
							goto l129
						}
						{
							position145 := position
							{
								position146 := position
								{
									position147 := position
									if !_rules[ruleNumber]() {
										goto l129
									}
									add(rulePegText, position147)
								}
								{
									add(ruleAction14, position)
								}
								add(ruleErrCode, position146)
							}
							{
								position149, tokenIndex149 := position, tokenIndex
								if !_rules[ruleERROR]() {
									goto l150
								}
								goto l149
							l150:
								position, tokenIndex = position149, tokenIndex149
								if !_rules[ruleOK]() {
									goto l129
								}
							}
						l149:
							{
								position151 := position
							l152:
								{
									position153, tokenIndex153 := position, tokenIndex
									if !_rules[ruleStringLike]() {
										goto l153
									}
									goto l152
								l153:
									position, tokenIndex = position153, tokenIndex153
								}
								add(rulePegText, position151)
							}
							{
								add(ruleAction13, position)
							}
							add(ruleErrorOrOkay, position145)
						}
						if !_rules[ruleEND]() {
							goto l129
						}
						{
							add(ruleAction0, position)
						}
						add(ruleResponse, position130)
					}
					goto l2
				l129:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[ruleWorldObject]() {
						goto l156
					}
					goto l2
				l156:
					position, tokenIndex = position2, tokenIndex2
					if !_rules[ruleTree]() {
						goto l0
					}
				}
			l2:
				add(ruleValid, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Response <- <(Objects? _ DELIMITER DELIMITER _ ErrorOrOkay END Action0)> */
		nil,
		/* 2 Command <- <(_ (Mutation / TreeMutation / Query / StateBound) Flag* END Action1)> */
		nil,
		/* 3 Mutation <- <((Item (Create / Set) Identifier ItemParams?) / (Item Clear Identifier ItemKeys) / (Item Delete Identifier) / (Rel (Create / Set) DualIdentifier RelParams?) / (Rel Clear DualIdentifier RelKeys) / (Rel Delete DualIdentifier))> */
		nil,
		/* 4 TreeMutation <- <((Free IdentifierList) / (Nest IdentifierList _ IN <StringLike> Action2))> */
		nil,
		/* 5 Query <- <(FetchQuery / ListQuery / ExistsQuery)> */
		nil,
		/* 6 FetchQuery <- <((&('w') (World Action3)) | (&('r') (Rel Fetch DualIdentifier)) | (&('i') (Item Fetch Identifier)))> */
		nil,
		/* 7 ListQuery <- <(((Item / Rel) List Limit?) / ((&('f') (FromQuery Identifier)) | (&('t') (ToQuery Identifier)) | (&('i') (Item IN Identifier Action4))))> */
		nil,
		/* 8 ExistsQuery <- <((InQuery DualIdentifier) / (ItemExists Identifier) / (RelExists DualIdentifier))> */
		nil,
		/* 9 StateBound <- <((CreateOrFetch Action5) / (CreateOrSet Action6))> */
		nil,
		/* 10 CreateOrFetch <- <((Item Identifier !ItemParams) / (Rel DualIdentifier !RelParams))> */
		nil,
		/* 11 CreateOrSet <- <((Item Identifier ItemParams) / (Rel DualIdentifier RelParams))> */
		nil,
		/* 12 Objects <- <(WorldObject / Tree / ItemObject+ / RelObject+ / IdentifierListObject)> */
		nil,
		/* 13 WorldObject <- <(BeginWorld WorldParams Tree RelObject* EndWorld Action7)> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				{
					position171 := position
					if !_rules[rule_]() {
						goto l169
					}
					if !_rules[ruleDELIMITER]() {
						goto l169
					}
					if !_rules[ruleWORLD]() {
						goto l169
					}
					if !_rules[rule_]() {
						goto l169
					}
					add(ruleBeginWorld, position171)
				}
				{
					position172 := position
					if !_rules[rule_]() {
						goto l169
					}
					{
						position173 := position
						{
							position174 := position
							if buffer[position] != rune('v') {
								goto l169
							}
							position++
							if buffer[position] != rune('e') {
								goto l169
							}
							position++
							if buffer[position] != rune('r') {
								goto l169
							}
							position++
							if buffer[position] != rune('s') {
								goto l169
							}
							position++
							if buffer[position] != rune('i') {
								goto l169
							}
							position++
							if buffer[position] != rune('o') {
								goto l169
							}
							position++
							if buffer[position] != rune('n') {
								goto l169
							}
							position++
							add(ruleVERSION, position174)
						}
						if !_rules[ruleEQUALS]() {
							goto l169
						}
						{
							position175 := position
							if !_rules[ruleNumber]() {
								goto l169
							}
							add(rulePegText, position175)
						}
						{
							add(ruleAction20, position)
						}
						add(ruleWorldParamVersion, position173)
					}
					if !_rules[rule_]() {
						goto l169
					}
					{
						position177 := position
						{
							position178 := position
							if buffer[position] != rune('i') {
								goto l169
							}
							position++
							if buffer[position] != rune('d') {
								goto l169
							}
							position++
							add(ruleID, position178)
						}
						if !_rules[ruleEQUALS]() {
							goto l169
						}
						{
							position179 := position
							if !_rules[ruleStringLike]() {
								goto l169
							}
							add(rulePegText, position179)
						}
						{
							add(ruleAction21, position)
						}
						add(ruleWorldParamId, position177)
					}
					if !_rules[rule_]() {
						goto l169
					}
					{
						position181 := position
						if !_rules[ruleNAME]() {
							goto l169
						}
						if !_rules[ruleEQUALS]() {
							goto l169
						}
						{
							position182 := position
							if !_rules[ruleStringLike]() {
								goto l169
							}
							add(rulePegText, position182)
						}
						{
							add(ruleAction22, position)
						}
						add(ruleWorldParamName, position181)
					}
					if !_rules[rule_]() {
						goto l169
					}
					{
						position184 := position
						if !_rules[ruleEXPANDED]() {
							goto l169
						}
						if !_rules[ruleEQUALS]() {
							goto l169
						}
						{
							position185 := position
							if !_rules[ruleStringLike]() {
								goto l169
							}
							add(rulePegText, position185)
						}
						{
							add(ruleAction23, position)
						}
						add(ruleWorldParamExpanded, position184)
					}
					if !_rules[rule_]() {
						goto l169
					}
					{
						add(ruleAction19, position)
					}
					add(ruleWorldParams, position172)
				}
				if !_rules[ruleTree]() {
					goto l169
				}
			l188:
				{
					position189, tokenIndex189 := position, tokenIndex
					if !_rules[ruleRelObject]() {
						goto l189
					}
					goto l188
				l189:
					position, tokenIndex = position189, tokenIndex189
				}
				{
					position190 := position
					if !_rules[rule_]() {
						goto l169
					}
					if !_rules[ruleENDWORLD]() {
						goto l169
					}
					if !_rules[ruleDELIMITER]() {
						goto l169
					}
					if !_rules[rule_]() {
						goto l169
					}
					add(ruleEndWorld, position190)
				}
				{
					add(ruleAction7, position)
				}
				add(ruleWorldObject, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 14 ItemObject <- <(<(Item Identifier ItemParams?)> Action8)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194 := position
					if !_rules[ruleItem]() {
						goto l192
					}
					if !_rules[ruleIdentifier]() {
						goto l192
					}
					{
						position195, tokenIndex195 := position, tokenIndex
						if !_rules[ruleItemParams]() {
							goto l195
						}
						goto l196
					l195:
						position, tokenIndex = position195, tokenIndex195
					}
				l196:
					add(rulePegText, position194)
				}
				{
					add(ruleAction8, position)
				}
				add(ruleItemObject, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 15 RelObject <- <(<(Rel DualIdentifier RelParams?)> Action9)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				{
					position200 := position
					if !_rules[ruleRel]() {
						goto l198
					}
					if !_rules[ruleDualIdentifier]() {
						goto l198
					}
					{
						position201, tokenIndex201 := position, tokenIndex
						if !_rules[ruleRelParams]() {
							goto l201
						}
						goto l202
					l201:
						position, tokenIndex = position201, tokenIndex201
					}
				l202:
					add(rulePegText, position200)
				}
				{
					add(ruleAction9, position)
				}
				add(ruleRelObject, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 16 IdentifierListObject <- <(IdentifierList Action10)> */
		nil,
		/* 17 Tree <- <(<('t' 'r' 'e' 'e' '{' (Nil / ItemObject) (':' ':' '[') Tree* (']' '}'))> _ Action11)> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				{
					position207 := position
					if buffer[position] != rune('t') {
						goto l205
					}
					position++
					if buffer[position] != rune('r') {
						goto l205
					}
					position++
					if buffer[position] != rune('e') {
						goto l205
					}
					position++
					if buffer[position] != rune('e') {
						goto l205
					}
					position++
					if buffer[position] != rune('{') {
						goto l205
					}
					position++
					{
						position208, tokenIndex208 := position, tokenIndex
						{
							position210 := position
							if buffer[position] != rune('n') {
								goto l209
							}
							position++
							if buffer[position] != rune('i') {
								goto l209
							}
							position++
							if buffer[position] != rune('l') {
								goto l209
							}
							position++
							{
								add(ruleAction12, position)
							}
							add(ruleNil, position210)
						}
						goto l208
					l209:
						position, tokenIndex = position208, tokenIndex208
						if !_rules[ruleItemObject]() {
							goto l205
						}
					}
				l208:
					if buffer[position] != rune(':') {
						goto l205
					}
					position++
					if buffer[position] != rune(':') {
						goto l205
					}
					position++
					if buffer[position] != rune('[') {
						goto l205
					}
					position++
				l212:
					{
						position213, tokenIndex213 := position, tokenIndex
						if !_rules[ruleTree]() {
							goto l213
						}
						goto l212
					l213:
						position, tokenIndex = position213, tokenIndex213
					}
					if buffer[position] != rune(']') {
						goto l205
					}
					position++
					if buffer[position] != rune('}') {
						goto l205
					}
					position++
					add(rulePegText, position207)
				}
				if !_rules[rule_]() {
					goto l205
				}
				{
					add(ruleAction11, position)
				}
				add(ruleTree, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 18 Nil <- <('n' 'i' 'l' Action12)> */
		nil,
		/* 19 ErrorOrOkay <- <(ErrCode (ERROR / OK) <StringLike*> Action13)> */
		nil,
		/* 20 ErrCode <- <(<Number> Action14)> */
		nil,
		/* 21 Limit <- <(<Number> Action15)> */
		nil,
		/* 22 Identifier <- <(!Keyword <StringLike> Action16)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleKeyword]() {
						goto l221
					}
					goto l219
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
				{
					position222 := position
					if !_rules[ruleStringLike]() {
						goto l219
					}
					add(rulePegText, position222)
				}
				{
					add(ruleAction16, position)
				}
				add(ruleIdentifier, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 23 SecondIdentifier <- <(!Keyword &Identifier <StringLike> Action17)> */
		nil,
		/* 24 DualIdentifier <- <(Identifier SecondIdentifier)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				if !_rules[ruleIdentifier]() {
					goto l225
				}
				{
					position227 := position
					{
						position228, tokenIndex228 := position, tokenIndex
						if !_rules[ruleKeyword]() {
							goto l228
						}
						goto l225
					l228:
						position, tokenIndex = position228, tokenIndex228
					}
					{
						position229, tokenIndex229 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l225
						}
						position, tokenIndex = position229, tokenIndex229
					}
					{
						position230 := position
						if !_rules[ruleStringLike]() {
							goto l225
						}
						add(rulePegText, position230)
					}
					{
						add(ruleAction17, position)
					}
					add(ruleSecondIdentifier, position227)
				}
				add(ruleDualIdentifier, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 25 IdentifierList <- <(<(Identifier Identifier*)> Action18)> */
		func() bool {
			position232, tokenIndex232 := position, tokenIndex
			{
				position233 := position
				{
					position234 := position
					if !_rules[ruleIdentifier]() {
						goto l232
					}
				l235:
					{
						position236, tokenIndex236 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l236
						}
						goto l235
					l236:
						position, tokenIndex = position236, tokenIndex236
					}
					add(rulePegText, position234)
				}
				{
					add(ruleAction18, position)
				}
				add(ruleIdentifierList, position233)
			}
			return true
		l232:
			position, tokenIndex = position232, tokenIndex232
			return false
		},
		/* 26 WorldParams <- <(_ WorldParamVersion _ WorldParamId _ WorldParamName _ WorldParamExpanded _ Action19)> */
		nil,
		/* 27 ItemParams <- <ItemParam+> */
		func() bool {
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				{
					position243 := position
					{
						position244, tokenIndex244 := position, tokenIndex
						if !_rules[ruleEXTERNAL]() {
							goto l245
						}
						if !_rules[ruleEQUALS]() {
							goto l245
						}
						{
							position246 := position
							if !_rules[ruleBoolean]() {
								goto l245
							}
							add(rulePegText, position246)
						}
						{
							add(ruleAction24, position)
						}
						goto l244
					l245:
						position, tokenIndex = position244, tokenIndex244
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l239
								}
								if !_rules[ruleEQUALS]() {
									goto l239
								}
								{
									position249 := position
									if !_rules[ruleStringLike]() {
										goto l239
									}
									add(rulePegText, position249)
								}
								{
									add(ruleAction28, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l239
								}
								if !_rules[ruleEQUALS]() {
									goto l239
								}
								{
									position251 := position
									if !_rules[ruleStringLike]() {
										goto l239
									}
									add(rulePegText, position251)
								}
								{
									add(ruleAction27, position)
								}
							case 'n':
								if !_rules[ruleNAME]() {
									goto l239
								}
								if !_rules[ruleEQUALS]() {
									goto l239
								}
								{
									position253 := position
									if !_rules[ruleStringLike]() {
										goto l239
									}
									add(rulePegText, position253)
								}
								{
									add(ruleAction26, position)
								}
							default:
								if !_rules[ruleTYPE]() {
									goto l239
								}
								if !_rules[ruleEQUALS]() {
									goto l239
								}
								{
									position255 := position
									{
										position256 := position
										{
											position257, tokenIndex257 := position, tokenIndex
											{
												position259 := position
												if buffer[position] != rune('d') {
													goto l258
												}
												position++
												if buffer[position] != rune('a') {
													goto l258
												}
												position++
												if buffer[position] != rune('t') {
													goto l258
												}
												position++
												if buffer[position] != rune('a') {
													goto l258
												}
												position++
												if buffer[position] != rune('b') {
													goto l258
												}
												position++
												if buffer[position] != rune('a') {
													goto l258
												}
												position++
												if buffer[position] != rune('s') {
													goto l258
												}
												position++
												if buffer[position] != rune('e') {
													goto l258
												}
												position++
												if !_rules[rule_]() {
													goto l258
												}
												add(ruleDATABASE, position259)
											}
											goto l257
										l258:
											position, tokenIndex = position257, tokenIndex257
											{
												position261 := position
												if buffer[position] != rune('b') {
													goto l260
												}
												position++
												if buffer[position] != rune('l') {
													goto l260
												}
												position++
												if buffer[position] != rune('o') {
													goto l260
												}
												position++
												if buffer[position] != rune('b') {
													goto l260
												}
												position++
												if buffer[position] != rune('s') {
													goto l260
												}
												position++
												if buffer[position] != rune('t') {
													goto l260
												}
												position++
												if buffer[position] != rune('o') {
													goto l260
												}
												position++
												if buffer[position] != rune('r') {
													goto l260
												}
												position++
												if buffer[position] != rune('e') {
													goto l260
												}
												position++
												if !_rules[rule_]() {
													goto l260
												}
												add(ruleBLOBSTORE, position261)
											}
											goto l257
										l260:
											position, tokenIndex = position257, tokenIndex257
											{
												switch buffer[position] {
												case 'c':
													{
														position263 := position
														if buffer[position] != rune('c') {
															goto l239
														}
														position++
														if buffer[position] != rune('o') {
															goto l239
														}
														position++
														if buffer[position] != rune('d') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleCODE, position263)
													}
												case 'd':
													{
														position264 := position
														if buffer[position] != rune('d') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('v') {
															goto l239
														}
														position++
														if buffer[position] != rune('i') {
															goto l239
														}
														position++
														if buffer[position] != rune('c') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleDEVICE, position264)
													}
												case 's':
													{
														position265 := position
														if buffer[position] != rune('s') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('r') {
															goto l239
														}
														position++
														if buffer[position] != rune('v') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('r') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleSERVER, position265)
													}
												case 'm':
													{
														position266 := position
														if buffer[position] != rune('m') {
															goto l239
														}
														position++
														if buffer[position] != rune('o') {
															goto l239
														}
														position++
														if buffer[position] != rune('b') {
															goto l239
														}
														position++
														if buffer[position] != rune('i') {
															goto l239
														}
														position++
														if buffer[position] != rune('l') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleMOBILE, position266)
													}
												case 'b':
													{
														position267 := position
														if buffer[position] != rune('b') {
															goto l239
														}
														position++
														if buffer[position] != rune('r') {
															goto l239
														}
														position++
														if buffer[position] != rune('o') {
															goto l239
														}
														position++
														if buffer[position] != rune('w') {
															goto l239
														}
														position++
														if buffer[position] != rune('s') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('r') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleBROWSER, position267)
													}
												case 'q':
													{
														position268 := position
														if buffer[position] != rune('q') {
															goto l239
														}
														position++
														if buffer[position] != rune('u') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('u') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(ruleQUEUE, position268)
													}
												default:
													{
														position269 := position
														if buffer[position] != rune('p') {
															goto l239
														}
														position++
														if buffer[position] != rune('e') {
															goto l239
														}
														position++
														if buffer[position] != rune('r') {
															goto l239
														}
														position++
														if buffer[position] != rune('s') {
															goto l239
														}
														position++
														if buffer[position] != rune('o') {
															goto l239
														}
														position++
														if buffer[position] != rune('n') {
															goto l239
														}
														position++
														if !_rules[rule_]() {
															goto l239
														}
														add(rulePERSON, position269)
													}
												}
											}

										}
									l257:
										add(ruleItemType, position256)
									}
									add(rulePegText, position255)
								}
								{
									add(ruleAction25, position)
								}
							}
						}

					}
				l244:
					add(ruleItemParam, position243)
				}
			l241:
				{
					position242, tokenIndex242 := position, tokenIndex
					{
						position271 := position
						{
							position272, tokenIndex272 := position, tokenIndex
							if !_rules[ruleEXTERNAL]() {
								goto l273
							}
							if !_rules[ruleEQUALS]() {
								goto l273
							}
							{
								position274 := position
								if !_rules[ruleBoolean]() {
									goto l273
								}
								add(rulePegText, position274)
							}
							{
								add(ruleAction24, position)
							}
							goto l272
						l273:
							position, tokenIndex = position272, tokenIndex272
							{
								switch buffer[position] {
								case 'e':
									if !_rules[ruleEXPANDED]() {
										goto l242
									}
									if !_rules[ruleEQUALS]() {
										goto l242
									}
									{
										position277 := position
										if !_rules[ruleStringLike]() {
											goto l242
										}
										add(rulePegText, position277)
									}
									{
										add(ruleAction28, position)
									}
								case 'm':
									if !_rules[ruleMECHANISM]() {
										goto l242
									}
									if !_rules[ruleEQUALS]() {
										goto l242
									}
									{
										position279 := position
										if !_rules[ruleStringLike]() {
											goto l242
										}
										add(rulePegText, position279)
									}
									{
										add(ruleAction27, position)
									}
								case 'n':
									if !_rules[ruleNAME]() {
										goto l242
									}
									if !_rules[ruleEQUALS]() {
										goto l242
									}
									{
										position281 := position
										if !_rules[ruleStringLike]() {
											goto l242
										}
										add(rulePegText, position281)
									}
									{
										add(ruleAction26, position)
									}
								default:
									if !_rules[ruleTYPE]() {
										goto l242
									}
									if !_rules[ruleEQUALS]() {
										goto l242
									}
									{
										position283 := position
										{
											position284 := position
											{
												position285, tokenIndex285 := position, tokenIndex
												{
													position287 := position
													if buffer[position] != rune('d') {
														goto l286
													}
													position++
													if buffer[position] != rune('a') {
														goto l286
													}
													position++
													if buffer[position] != rune('t') {
														goto l286
													}
													position++
													if buffer[position] != rune('a') {
														goto l286
													}
													position++
													if buffer[position] != rune('b') {
														goto l286
													}
													position++
													if buffer[position] != rune('a') {
														goto l286
													}
													position++
													if buffer[position] != rune('s') {
														goto l286
													}
													position++
													if buffer[position] != rune('e') {
														goto l286
													}
													position++
													if !_rules[rule_]() {
														goto l286
													}
													add(ruleDATABASE, position287)
												}
												goto l285
											l286:
												position, tokenIndex = position285, tokenIndex285
												{
													position289 := position
													if buffer[position] != rune('b') {
														goto l288
													}
													position++
													if buffer[position] != rune('l') {
														goto l288
													}
													position++
													if buffer[position] != rune('o') {
														goto l288
													}
													position++
													if buffer[position] != rune('b') {
														goto l288
													}
													position++
													if buffer[position] != rune('s') {
														goto l288
													}
													position++
													if buffer[position] != rune('t') {
														goto l288
													}
													position++
													if buffer[position] != rune('o') {
														goto l288
													}
													position++
													if buffer[position] != rune('r') {
														goto l288
													}
													position++
													if buffer[position] != rune('e') {
														goto l288
													}
													position++
													if !_rules[rule_]() {
														goto l288
													}
													add(ruleBLOBSTORE, position289)
												}
												goto l285
											l288:
												position, tokenIndex = position285, tokenIndex285
												{
													switch buffer[position] {
													case 'c':
														{
															position291 := position
															if buffer[position] != rune('c') {
																goto l242
															}
															position++
															if buffer[position] != rune('o') {
																goto l242
															}
															position++
															if buffer[position] != rune('d') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleCODE, position291)
														}
													case 'd':
														{
															position292 := position
															if buffer[position] != rune('d') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('v') {
																goto l242
															}
															position++
															if buffer[position] != rune('i') {
																goto l242
															}
															position++
															if buffer[position] != rune('c') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleDEVICE, position292)
														}
													case 's':
														{
															position293 := position
															if buffer[position] != rune('s') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('r') {
																goto l242
															}
															position++
															if buffer[position] != rune('v') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('r') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleSERVER, position293)
														}
													case 'm':
														{
															position294 := position
															if buffer[position] != rune('m') {
																goto l242
															}
															position++
															if buffer[position] != rune('o') {
																goto l242
															}
															position++
															if buffer[position] != rune('b') {
																goto l242
															}
															position++
															if buffer[position] != rune('i') {
																goto l242
															}
															position++
															if buffer[position] != rune('l') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleMOBILE, position294)
														}
													case 'b':
														{
															position295 := position
															if buffer[position] != rune('b') {
																goto l242
															}
															position++
															if buffer[position] != rune('r') {
																goto l242
															}
															position++
															if buffer[position] != rune('o') {
																goto l242
															}
															position++
															if buffer[position] != rune('w') {
																goto l242
															}
															position++
															if buffer[position] != rune('s') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('r') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleBROWSER, position295)
														}
													case 'q':
														{
															position296 := position
															if buffer[position] != rune('q') {
																goto l242
															}
															position++
															if buffer[position] != rune('u') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('u') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(ruleQUEUE, position296)
														}
													default:
														{
															position297 := position
															if buffer[position] != rune('p') {
																goto l242
															}
															position++
															if buffer[position] != rune('e') {
																goto l242
															}
															position++
															if buffer[position] != rune('r') {
																goto l242
															}
															position++
															if buffer[position] != rune('s') {
																goto l242
															}
															position++
															if buffer[position] != rune('o') {
																goto l242
															}
															position++
															if buffer[position] != rune('n') {
																goto l242
															}
															position++
															if !_rules[rule_]() {
																goto l242
															}
															add(rulePERSON, position297)
														}
													}
												}

											}
										l285:
											add(ruleItemType, position284)
										}
										add(rulePegText, position283)
									}
									{
										add(ruleAction25, position)
									}
								}
							}

						}
					l272:
						add(ruleItemParam, position271)
					}
					goto l241
				l242:
					position, tokenIndex = position242, tokenIndex242
				}
				add(ruleItemParams, position240)
			}
			return true
		l239:
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 28 RelParams <- <RelParam+> */
		func() bool {
			position299, tokenIndex299 := position, tokenIndex
			{
				position300 := position
				{
					position303 := position
					{
						switch buffer[position] {
						case 'e':
							if !_rules[ruleEXPANDED]() {
								goto l299
							}
							if !_rules[ruleEQUALS]() {
								goto l299
							}
							{
								position305 := position
								if !_rules[ruleStringLike]() {
									goto l299
								}
								add(rulePegText, position305)
							}
							{
								add(ruleAction32, position)
							}
						case 'a':
							if !_rules[ruleASYNC]() {
								goto l299
							}
							if !_rules[ruleEQUALS]() {
								goto l299
							}
							{
								position307 := position
								if !_rules[ruleBoolean]() {
									goto l299
								}
								add(rulePegText, position307)
							}
							{
								add(ruleAction31, position)
							}
						case 'm':
							if !_rules[ruleMECHANISM]() {
								goto l299
							}
							if !_rules[ruleEQUALS]() {
								goto l299
							}
							{
								position309 := position
								if !_rules[ruleStringLike]() {
									goto l299
								}
								add(rulePegText, position309)
							}
							{
								add(ruleAction30, position)
							}
						default:
							if !_rules[ruleVERB]() {
								goto l299
							}
							if !_rules[ruleEQUALS]() {
								goto l299
							}
							{
								position311 := position
								if !_rules[ruleStringLike]() {
									goto l299
								}
								add(rulePegText, position311)
							}
							{
								add(ruleAction29, position)
							}
						}
					}

					add(ruleRelParam, position303)
				}
			l301:
				{
					position302, tokenIndex302 := position, tokenIndex
					{
						position313 := position
						{
							switch buffer[position] {
							case 'e':
								if !_rules[ruleEXPANDED]() {
									goto l302
								}
								if !_rules[ruleEQUALS]() {
									goto l302
								}
								{
									position315 := position
									if !_rules[ruleStringLike]() {
										goto l302
									}
									add(rulePegText, position315)
								}
								{
									add(ruleAction32, position)
								}
							case 'a':
								if !_rules[ruleASYNC]() {
									goto l302
								}
								if !_rules[ruleEQUALS]() {
									goto l302
								}
								{
									position317 := position
									if !_rules[ruleBoolean]() {
										goto l302
									}
									add(rulePegText, position317)
								}
								{
									add(ruleAction31, position)
								}
							case 'm':
								if !_rules[ruleMECHANISM]() {
									goto l302
								}
								if !_rules[ruleEQUALS]() {
									goto l302
								}
								{
									position319 := position
									if !_rules[ruleStringLike]() {
										goto l302
									}
									add(rulePegText, position319)
								}
								{
									add(ruleAction30, position)
								}
							default:
								if !_rules[ruleVERB]() {
									goto l302
								}
								if !_rules[ruleEQUALS]() {
									goto l302
								}
								{
									position321 := position
									if !_rules[ruleStringLike]() {
										goto l302
									}
									add(rulePegText, position321)
								}
								{
									add(ruleAction29, position)
								}
							}
						}

						add(ruleRelParam, position313)
					}
					goto l301
				l302:
					position, tokenIndex = position302, tokenIndex302
				}
				add(ruleRelParams, position300)
			}
			return true
		l299:
			position, tokenIndex = position299, tokenIndex299
			return false
		},
		/* 29 WorldParamVersion <- <(VERSION EQUALS <Number> Action20)> */
		nil,
		/* 30 WorldParamId <- <(ID EQUALS <StringLike> Action21)> */
		nil,
		/* 31 WorldParamName <- <(NAME EQUALS <StringLike> Action22)> */
		nil,
		/* 32 WorldParamExpanded <- <(EXPANDED EQUALS <StringLike> Action23)> */
		nil,
		/* 33 ItemParam <- <((EXTERNAL EQUALS <Boolean> Action24) / ((&('e') (EXPANDED EQUALS <StringLike> Action28)) | (&('m') (MECHANISM EQUALS <StringLike> Action27)) | (&('n') (NAME EQUALS <StringLike> Action26)) | (&('t') (TYPE EQUALS <ItemType> Action25))))> */
		nil,
		/* 34 RelParam <- <((&('e') (EXPANDED EQUALS <StringLike> Action32)) | (&('a') (ASYNC EQUALS <Boolean> Action31)) | (&('m') (MECHANISM EQUALS <StringLike> Action30)) | (&('v') (VERB EQUALS <StringLike> Action29)))> */
		nil,
		/* 35 ItemKeys <- <ItemKey+> */
		nil,
		/* 36 RelKeys <- <RelKey+> */
		nil,
		/* 37 ItemKey <- <(<(EXTERNAL / ((&('e') EXPANDED) | (&('m') MECHANISM) | (&('t') TYPE) | (&('n') NAME)))> _ Action33)> */
		nil,
		/* 38 RelKey <- <(<((&('e') EXPANDED) | (&('a') ASYNC) | (&('m') MECHANISM) | (&('v') VERB))> _ Action34)> */
		nil,
		/* 39 StringLike <- <(<(Text / QuotedText)> _ Action35)> */
		func() bool {
			position333, tokenIndex333 := position, tokenIndex
			{
				position334 := position
				{
					position335 := position
					{
						position336, tokenIndex336 := position, tokenIndex
						{
							position338 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l337
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l337
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l337
									}
									position++
								case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l337
									}
									position++
								default:
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l337
									}
									position++
								}
							}

						l339:
							{
								position340, tokenIndex340 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l340
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l340
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l340
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l340
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l340
										}
										position++
									}
								}

								goto l339
							l340:
								position, tokenIndex = position340, tokenIndex340
							}
							add(ruleText, position338)
						}
						goto l336
					l337:
						position, tokenIndex = position336, tokenIndex336
						{
							position343 := position
							if !_rules[ruleQUOTE]() {
								goto l333
							}
						l344:
							{
								position345, tokenIndex345 := position, tokenIndex
								{
									switch buffer[position] {
									case ' ':
										if buffer[position] != rune(' ') {
											goto l345
										}
										position++
									case ':':
										if buffer[position] != rune(':') {
											goto l345
										}
										position++
									case ';':
										if buffer[position] != rune(';') {
											goto l345
										}
										position++
									case '~':
										if buffer[position] != rune('~') {
											goto l345
										}
										position++
									case '=':
										if buffer[position] != rune('=') {
											goto l345
										}
										position++
									case '+':
										if buffer[position] != rune('+') {
											goto l345
										}
										position++
									case ']':
										if buffer[position] != rune(']') {
											goto l345
										}
										position++
									case '[':
										if buffer[position] != rune('[') {
											goto l345
										}
										position++
									case ')':
										if buffer[position] != rune(')') {
											goto l345
										}
										position++
									case '(':
										if buffer[position] != rune('(') {
											goto l345
										}
										position++
									case '*':
										if buffer[position] != rune('*') {
											goto l345
										}
										position++
									case '&':
										if buffer[position] != rune('&') {
											goto l345
										}
										position++
									case '^':
										if buffer[position] != rune('^') {
											goto l345
										}
										position++
									case '%':
										if buffer[position] != rune('%') {
											goto l345
										}
										position++
									case '$':
										if buffer[position] != rune('$') {
											goto l345
										}
										position++
									case '#':
										if buffer[position] != rune('#') {
											goto l345
										}
										position++
									case '@':
										if buffer[position] != rune('@') {
											goto l345
										}
										position++
									case '!':
										if buffer[position] != rune('!') {
											goto l345
										}
										position++
									case ',':
										if buffer[position] != rune(',') {
											goto l345
										}
										position++
									case '.':
										if buffer[position] != rune('.') {
											goto l345
										}
										position++
									case '_':
										if buffer[position] != rune('_') {
											goto l345
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l345
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l345
										}
										position++
									case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l345
										}
										position++
									default:
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l345
										}
										position++
									}
								}

								goto l344
							l345:
								position, tokenIndex = position345, tokenIndex345
							}
							if !_rules[ruleQUOTE]() {
								goto l333
							}
							add(ruleQuotedText, position343)
						}
					}
				l336:
					add(rulePegText, position335)
				}
				if !_rules[rule_]() {
					goto l333
				}
				{
					add(ruleAction35, position)
				}
				add(ruleStringLike, position334)
			}
			return true
		l333:
			position, tokenIndex = position333, tokenIndex333
			return false
		},
		/* 40 Number <- <(<[0-9]+> _ Action36)> */
		func() bool {
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				{
					position350 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l348
					}
					position++
				l351:
					{
						position352, tokenIndex352 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l352
						}
						position++
						goto l351
					l352:
						position, tokenIndex = position352, tokenIndex352
					}
					add(rulePegText, position350)
				}
				if !_rules[rule_]() {
					goto l348
				}
				{
					add(ruleAction36, position)
				}
				add(ruleNumber, position349)
			}
			return true
		l348:
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 41 Boolean <- <(<(TRUE / FALSE)> Action37)> */
		func() bool {
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				{
					position356 := position
					{
						position357, tokenIndex357 := position, tokenIndex
						{
							position359 := position
							if buffer[position] != rune('t') {
								goto l358
							}
							position++
							if buffer[position] != rune('r') {
								goto l358
							}
							position++
							if buffer[position] != rune('u') {
								goto l358
							}
							position++
							if buffer[position] != rune('e') {
								goto l358
							}
							position++
							if !_rules[rule_]() {
								goto l358
							}
							add(ruleTRUE, position359)
						}
						goto l357
					l358:
						position, tokenIndex = position357, tokenIndex357
						{
							position360 := position
							if buffer[position] != rune('f') {
								goto l354
							}
							position++
							if buffer[position] != rune('a') {
								goto l354
							}
							position++
							if buffer[position] != rune('l') {
								goto l354
							}
							position++
							if buffer[position] != rune('s') {
								goto l354
							}
							position++
							if buffer[position] != rune('e') {
								goto l354
							}
							position++
							if !_rules[rule_]() {
								goto l354
							}
							add(ruleFALSE, position360)
						}
					}
				l357:
					add(rulePegText, position356)
				}
				{
					add(ruleAction37, position)
				}
				add(ruleBoolean, position355)
			}
			return true
		l354:
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 42 Text <- <((&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> */
		nil,
		/* 43 QuotedText <- <(QUOTE ((&(' ') ' ') | (&(':') ':') | (&(';') ';') | (&('~') '~') | (&('=') '=') | (&('+') '+') | (&(']') ']') | (&('[') '[') | (&(')') ')') | (&('(') '(') | (&('*') '*') | (&('&') '&') | (&('^') '^') | (&('%') '%') | (&('$') '$') | (&('#') '#') | (&('@') '@') | (&('!') '!') | (&(',') ',') | (&('.') '.') | (&('_') '_') | (&('-') '-') | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))* QUOTE)> */
		nil,
		/* 44 ItemExists <- <((ITEM_EXISTS / (Item Exists)) Action38)> */
		nil,
		/* 45 RelExists <- <((REL_EXISTS / (Rel Exists)) Action39)> */
		nil,
		/* 46 World <- <(WORLD Action40)> */
		nil,
		/* 47 Item <- <(ITEM Action41)> */
		func() bool {
			position367, tokenIndex367 := position, tokenIndex
			{
				position368 := position
				if !_rules[ruleITEM]() {
					goto l367
				}
				{
					add(ruleAction41, position)
				}
				add(ruleItem, position368)
			}
			return true
		l367:
			position, tokenIndex = position367, tokenIndex367
			return false
		},
		/* 48 Rel <- <(REL Action42)> */
		func() bool {
			position370, tokenIndex370 := position, tokenIndex
			{
				position371 := position
				if !_rules[ruleREL]() {
					goto l370
				}
				{
					add(ruleAction42, position)
				}
				add(ruleRel, position371)
			}
			return true
		l370:
			position, tokenIndex = position370, tokenIndex370
			return false
		},
		/* 49 Create <- <(CREATE Action43)> */
		func() bool {
			position373, tokenIndex373 := position, tokenIndex
			{
				position374 := position
				if !_rules[ruleCREATE]() {
					goto l373
				}
				{
					add(ruleAction43, position)
				}
				add(ruleCreate, position374)
			}
			return true
		l373:
			position, tokenIndex = position373, tokenIndex373
			return false
		},
		/* 50 Fetch <- <(FETCH Action44)> */
		func() bool {
			position376, tokenIndex376 := position, tokenIndex
			{
				position377 := position
				if !_rules[ruleFETCH]() {
					goto l376
				}
				{
					add(ruleAction44, position)
				}
				add(ruleFetch, position377)
			}
			return true
		l376:
			position, tokenIndex = position376, tokenIndex376
			return false
		},
		/* 51 Set <- <(SET Action45)> */
		func() bool {
			position379, tokenIndex379 := position, tokenIndex
			{
				position380 := position
				if !_rules[ruleSET]() {
					goto l379
				}
				{
					add(ruleAction45, position)
				}
				add(ruleSet, position380)
			}
			return true
		l379:
			position, tokenIndex = position379, tokenIndex379
			return false
		},
		/* 52 Clear <- <(CLEAR Action46)> */
		func() bool {
			position382, tokenIndex382 := position, tokenIndex
			{
				position383 := position
				if !_rules[ruleCLEAR]() {
					goto l382
				}
				{
					add(ruleAction46, position)
				}
				add(ruleClear, position383)
			}
			return true
		l382:
			position, tokenIndex = position382, tokenIndex382
			return false
		},
		/* 53 Delete <- <(DELETE Action47)> */
		func() bool {
			position385, tokenIndex385 := position, tokenIndex
			{
				position386 := position
				if !_rules[ruleDELETE]() {
					goto l385
				}
				{
					add(ruleAction47, position)
				}
				add(ruleDelete, position386)
			}
			return true
		l385:
			position, tokenIndex = position385, tokenIndex385
			return false
		},
		/* 54 List <- <(LIST Action48)> */
		nil,
		/* 55 Nest <- <(NEST Action49)> */
		nil,
		/* 56 Free <- <(FREE Action50)> */
		nil,
		/* 57 Exists <- <(EXISTS Action51)> */
		func() bool {
			position391, tokenIndex391 := position, tokenIndex
			{
				position392 := position
				if !_rules[ruleEXISTS]() {
					goto l391
				}
				{
					add(ruleAction51, position)
				}
				add(ruleExists, position392)
			}
			return true
		l391:
			position, tokenIndex = position391, tokenIndex391
			return false
		},
		/* 58 InQuery <- <(IN_QUERY Action52)> */
		nil,
		/* 59 FromQuery <- <(FROM_QUERY Action53)> */
		nil,
		/* 60 ToQuery <- <(TO_QUERY Action54)> */
		nil,
		/* 61 Flag <- <(StrictFlag / VerboseFlag / IdsFlag)> */
		nil,
		/* 62 StrictFlag <- <(FLAG STRICT Action55)> */
		nil,
		/* 63 VerboseFlag <- <(FLAG VERBOSE Action56)> */
		nil,
		/* 64 IdsFlag <- <(FLAG IDS Action57)> */
		nil,
		/* 65 BeginWorld <- <(_ DELIMITER WORLD _)> */
		nil,
		/* 66 EndWorld <- <(_ ENDWORLD DELIMITER _)> */
		nil,
		/* 67 ItemType <- <(DATABASE / BLOBSTORE / ((&('c') CODE) | (&('d') DEVICE) | (&('s') SERVER) | (&('m') MOBILE) | (&('b') BROWSER) | (&('q') QUEUE) | (&('p') PERSON)))> */
		nil,
		/* 68 Keyword <- <(ENDWORLD / ERROR / ITEM / ITEM_EXISTS / REL / FROM_QUERY / IN / CREATE / FETCH / ((&('$') DELIMITER) | (&('-') FLAG) | (&('n') NEST) | (&('f') FREE) | (&('e') EXISTS) | (&('l') LIST) | (&('c') CLEAR) | (&('s') SET) | (&('d') DELETE) | (&('i') IN_QUERY) | (&('t') TO_QUERY) | (&('r') REL_EXISTS) | (&('o') OK) | (&('w') WORLD)))> */
		func() bool {
			position404, tokenIndex404 := position, tokenIndex
			{
				position405 := position
				{
					position406, tokenIndex406 := position, tokenIndex
					if !_rules[ruleENDWORLD]() {
						goto l407
					}
					goto l406
				l407:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleERROR]() {
						goto l408
					}
					goto l406
				l408:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleITEM]() {
						goto l409
					}
					goto l406
				l409:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleITEM_EXISTS]() {
						goto l410
					}
					goto l406
				l410:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleREL]() {
						goto l411
					}
					goto l406
				l411:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleFROM_QUERY]() {
						goto l412
					}
					goto l406
				l412:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleIN]() {
						goto l413
					}
					goto l406
				l413:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleCREATE]() {
						goto l414
					}
					goto l406
				l414:
					position, tokenIndex = position406, tokenIndex406
					if !_rules[ruleFETCH]() {
						goto l415
					}
					goto l406
				l415:
					position, tokenIndex = position406, tokenIndex406
					{
						switch buffer[position] {
						case '$':
							if !_rules[ruleDELIMITER]() {
								goto l404
							}
						case '-':
							if !_rules[ruleFLAG]() {
								goto l404
							}
						case 'n':
							if !_rules[ruleNEST]() {
								goto l404
							}
						case 'f':
							if !_rules[ruleFREE]() {
								goto l404
							}
						case 'e':
							if !_rules[ruleEXISTS]() {
								goto l404
							}
						case 'l':
							if !_rules[ruleLIST]() {
								goto l404
							}
						case 'c':
							if !_rules[ruleCLEAR]() {
								goto l404
							}
						case 's':
							if !_rules[ruleSET]() {
								goto l404
							}
						case 'd':
							if !_rules[ruleDELETE]() {
								goto l404
							}
						case 'i':
							if !_rules[ruleIN_QUERY]() {
								goto l404
							}
						case 't':
							if !_rules[ruleTO_QUERY]() {
								goto l404
							}
						case 'r':
							if !_rules[ruleREL_EXISTS]() {
								goto l404
							}
						case 'o':
							if !_rules[ruleOK]() {
								goto l404
							}
						default:
							if !_rules[ruleWORLD]() {
								goto l404
							}
						}
					}

				}
			l406:
				add(ruleKeyword, position405)
			}
			return true
		l404:
			position, tokenIndex = position404, tokenIndex404
			return false
		},
		/* 69 WORLD <- <('w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position417, tokenIndex417 := position, tokenIndex
			{
				position418 := position
				if buffer[position] != rune('w') {
					goto l417
				}
				position++
				if buffer[position] != rune('o') {
					goto l417
				}
				position++
				if buffer[position] != rune('r') {
					goto l417
				}
				position++
				if buffer[position] != rune('l') {
					goto l417
				}
				position++
				if buffer[position] != rune('d') {
					goto l417
				}
				position++
				if !_rules[rule_]() {
					goto l417
				}
				add(ruleWORLD, position418)
			}
			return true
		l417:
			position, tokenIndex = position417, tokenIndex417
			return false
		},
		/* 70 ENDWORLD <- <('e' 'n' 'd' 'w' 'o' 'r' 'l' 'd' _)> */
		func() bool {
			position419, tokenIndex419 := position, tokenIndex
			{
				position420 := position
				if buffer[position] != rune('e') {
					goto l419
				}
				position++
				if buffer[position] != rune('n') {
					goto l419
				}
				position++
				if buffer[position] != rune('d') {
					goto l419
				}
				position++
				if buffer[position] != rune('w') {
					goto l419
				}
				position++
				if buffer[position] != rune('o') {
					goto l419
				}
				position++
				if buffer[position] != rune('r') {
					goto l419
				}
				position++
				if buffer[position] != rune('l') {
					goto l419
				}
				position++
				if buffer[position] != rune('d') {
					goto l419
				}
				position++
				if !_rules[rule_]() {
					goto l419
				}
				add(ruleENDWORLD, position420)
			}
			return true
		l419:
			position, tokenIndex = position419, tokenIndex419
			return false
		},
		/* 71 ERROR <- <('e' 'r' 'r' 'o' 'r' _)> */
		func() bool {
			position421, tokenIndex421 := position, tokenIndex
			{
				position422 := position
				if buffer[position] != rune('e') {
					goto l421
				}
				position++
				if buffer[position] != rune('r') {
					goto l421
				}
				position++
				if buffer[position] != rune('r') {
					goto l421
				}
				position++
				if buffer[position] != rune('o') {
					goto l421
				}
				position++
				if buffer[position] != rune('r') {
					goto l421
				}
				position++
				if !_rules[rule_]() {
					goto l421
				}
				add(ruleERROR, position422)
			}
			return true
		l421:
			position, tokenIndex = position421, tokenIndex421
			return false
		},
		/* 72 OK <- <('o' 'k' _)> */
		func() bool {
			position423, tokenIndex423 := position, tokenIndex
			{
				position424 := position
				if buffer[position] != rune('o') {
					goto l423
				}
				position++
				if buffer[position] != rune('k') {
					goto l423
				}
				position++
				if !_rules[rule_]() {
					goto l423
				}
				add(ruleOK, position424)
			}
			return true
		l423:
			position, tokenIndex = position423, tokenIndex423
			return false
		},
		/* 73 ITEM <- <('i' 't' 'e' 'm' 's'? _)> */
		func() bool {
			position425, tokenIndex425 := position, tokenIndex
			{
				position426 := position
				if buffer[position] != rune('i') {
					goto l425
				}
				position++
				if buffer[position] != rune('t') {
					goto l425
				}
				position++
				if buffer[position] != rune('e') {
					goto l425
				}
				position++
				if buffer[position] != rune('m') {
					goto l425
				}
				position++
				{
					position427, tokenIndex427 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l427
					}
					position++
					goto l428
				l427:
					position, tokenIndex = position427, tokenIndex427
				}
			l428:
				if !_rules[rule_]() {
					goto l425
				}
				add(ruleITEM, position426)
			}
			return true
		l425:
			position, tokenIndex = position425, tokenIndex425
			return false
		},
		/* 74 ITEM_EXISTS <- <('i' 't' 'e' 'm' '?' _)> */
		func() bool {
			position429, tokenIndex429 := position, tokenIndex
			{
				position430 := position
				if buffer[position] != rune('i') {
					goto l429
				}
				position++
				if buffer[position] != rune('t') {
					goto l429
				}
				position++
				if buffer[position] != rune('e') {
					goto l429
				}
				position++
				if buffer[position] != rune('m') {
					goto l429
				}
				position++
				if buffer[position] != rune('?') {
					goto l429
				}
				position++
				if !_rules[rule_]() {
					goto l429
				}
				add(ruleITEM_EXISTS, position430)
			}
			return true
		l429:
			position, tokenIndex = position429, tokenIndex429
			return false
		},
		/* 75 REL <- <('r' 'e' 'l' 's'? _)> */
		func() bool {
			position431, tokenIndex431 := position, tokenIndex
			{
				position432 := position
				if buffer[position] != rune('r') {
					goto l431
				}
				position++
				if buffer[position] != rune('e') {
					goto l431
				}
				position++
				if buffer[position] != rune('l') {
					goto l431
				}
				position++
				{
					position433, tokenIndex433 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l433
					}
					position++
					goto l434
				l433:
					position, tokenIndex = position433, tokenIndex433
				}
			l434:
				if !_rules[rule_]() {
					goto l431
				}
				add(ruleREL, position432)
			}
			return true
		l431:
			position, tokenIndex = position431, tokenIndex431
			return false
		},
		/* 76 REL_EXISTS <- <('r' 'e' 'l' '?' _)> */
		func() bool {
			position435, tokenIndex435 := position, tokenIndex
			{
				position436 := position
				if buffer[position] != rune('r') {
					goto l435
				}
				position++
				if buffer[position] != rune('e') {
					goto l435
				}
				position++
				if buffer[position] != rune('l') {
					goto l435
				}
				position++
				if buffer[position] != rune('?') {
					goto l435
				}
				position++
				if !_rules[rule_]() {
					goto l435
				}
				add(ruleREL_EXISTS, position436)
			}
			return true
		l435:
			position, tokenIndex = position435, tokenIndex435
			return false
		},
		/* 77 FROM_QUERY <- <('f' 'r' 'o' 'm' '?' _)> */
		func() bool {
			position437, tokenIndex437 := position, tokenIndex
			{
				position438 := position
				if buffer[position] != rune('f') {
					goto l437
				}
				position++
				if buffer[position] != rune('r') {
					goto l437
				}
				position++
				if buffer[position] != rune('o') {
					goto l437
				}
				position++
				if buffer[position] != rune('m') {
					goto l437
				}
				position++
				if buffer[position] != rune('?') {
					goto l437
				}
				position++
				if !_rules[rule_]() {
					goto l437
				}
				add(ruleFROM_QUERY, position438)
			}
			return true
		l437:
			position, tokenIndex = position437, tokenIndex437
			return false
		},
		/* 78 TO_QUERY <- <('t' 'o' '?' _)> */
		func() bool {
			position439, tokenIndex439 := position, tokenIndex
			{
				position440 := position
				if buffer[position] != rune('t') {
					goto l439
				}
				position++
				if buffer[position] != rune('o') {
					goto l439
				}
				position++
				if buffer[position] != rune('?') {
					goto l439
				}
				position++
				if !_rules[rule_]() {
					goto l439
				}
				add(ruleTO_QUERY, position440)
			}
			return true
		l439:
			position, tokenIndex = position439, tokenIndex439
			return false
		},
		/* 79 IN <- <('i' 'n' _)> */
		func() bool {
			position441, tokenIndex441 := position, tokenIndex
			{
				position442 := position
				if buffer[position] != rune('i') {
					goto l441
				}
				position++
				if buffer[position] != rune('n') {
					goto l441
				}
				position++
				if !_rules[rule_]() {
					goto l441
				}
				add(ruleIN, position442)
			}
			return true
		l441:
			position, tokenIndex = position441, tokenIndex441
			return false
		},
		/* 80 IN_QUERY <- <('i' 'n' '?' _)> */
		func() bool {
			position443, tokenIndex443 := position, tokenIndex
			{
				position444 := position
				if buffer[position] != rune('i') {
					goto l443
				}
				position++
				if buffer[position] != rune('n') {
					goto l443
				}
				position++
				if buffer[position] != rune('?') {
					goto l443
				}
				position++
				if !_rules[rule_]() {
					goto l443
				}
				add(ruleIN_QUERY, position444)
			}
			return true
		l443:
			position, tokenIndex = position443, tokenIndex443
			return false
		},
		/* 81 CREATE <- <('c' 'r' 'e' 'a' 't' 'e' _)> */
		func() bool {
			position445, tokenIndex445 := position, tokenIndex
			{
				position446 := position
				if buffer[position] != rune('c') {
					goto l445
				}
				position++
				if buffer[position] != rune('r') {
					goto l445
				}
				position++
				if buffer[position] != rune('e') {
					goto l445
				}
				position++
				if buffer[position] != rune('a') {
					goto l445
				}
				position++
				if buffer[position] != rune('t') {
					goto l445
				}
				position++
				if buffer[position] != rune('e') {
					goto l445
				}
				position++
				if !_rules[rule_]() {
					goto l445
				}
				add(ruleCREATE, position446)
			}
			return true
		l445:
			position, tokenIndex = position445, tokenIndex445
			return false
		},
		/* 82 DELETE <- <('d' 'e' 'l' 'e' 't' 'e' _)> */
		func() bool {
			position447, tokenIndex447 := position, tokenIndex
			{
				position448 := position
				if buffer[position] != rune('d') {
					goto l447
				}
				position++
				if buffer[position] != rune('e') {
					goto l447
				}
				position++
				if buffer[position] != rune('l') {
					goto l447
				}
				position++
				if buffer[position] != rune('e') {
					goto l447
				}
				position++
				if buffer[position] != rune('t') {
					goto l447
				}
				position++
				if buffer[position] != rune('e') {
					goto l447
				}
				position++
				if !_rules[rule_]() {
					goto l447
				}
				add(ruleDELETE, position448)
			}
			return true
		l447:
			position, tokenIndex = position447, tokenIndex447
			return false
		},
		/* 83 SET <- <('s' 'e' 't' _)> */
		func() bool {
			position449, tokenIndex449 := position, tokenIndex
			{
				position450 := position
				if buffer[position] != rune('s') {
					goto l449
				}
				position++
				if buffer[position] != rune('e') {
					goto l449
				}
				position++
				if buffer[position] != rune('t') {
					goto l449
				}
				position++
				if !_rules[rule_]() {
					goto l449
				}
				add(ruleSET, position450)
			}
			return true
		l449:
			position, tokenIndex = position449, tokenIndex449
			return false
		},
		/* 84 CLEAR <- <('c' 'l' 'e' 'a' 'r' _)> */
		func() bool {
			position451, tokenIndex451 := position, tokenIndex
			{
				position452 := position
				if buffer[position] != rune('c') {
					goto l451
				}
				position++
				if buffer[position] != rune('l') {
					goto l451
				}
				position++
				if buffer[position] != rune('e') {
					goto l451
				}
				position++
				if buffer[position] != rune('a') {
					goto l451
				}
				position++
				if buffer[position] != rune('r') {
					goto l451
				}
				position++
				if !_rules[rule_]() {
					goto l451
				}
				add(ruleCLEAR, position452)
			}
			return true
		l451:
			position, tokenIndex = position451, tokenIndex451
			return false
		},
		/* 85 FETCH <- <('f' 'e' 't' 'c' 'h' _)> */
		func() bool {
			position453, tokenIndex453 := position, tokenIndex
			{
				position454 := position
				if buffer[position] != rune('f') {
					goto l453
				}
				position++
				if buffer[position] != rune('e') {
					goto l453
				}
				position++
				if buffer[position] != rune('t') {
					goto l453
				}
				position++
				if buffer[position] != rune('c') {
					goto l453
				}
				position++
				if buffer[position] != rune('h') {
					goto l453
				}
				position++
				if !_rules[rule_]() {
					goto l453
				}
				add(ruleFETCH, position454)
			}
			return true
		l453:
			position, tokenIndex = position453, tokenIndex453
			return false
		},
		/* 86 LIST <- <('l' 'i' 's' 't' _)> */
		func() bool {
			position455, tokenIndex455 := position, tokenIndex
			{
				position456 := position
				if buffer[position] != rune('l') {
					goto l455
				}
				position++
				if buffer[position] != rune('i') {
					goto l455
				}
				position++
				if buffer[position] != rune('s') {
					goto l455
				}
				position++
				if buffer[position] != rune('t') {
					goto l455
				}
				position++
				if !_rules[rule_]() {
					goto l455
				}
				add(ruleLIST, position456)
			}
			return true
		l455:
			position, tokenIndex = position455, tokenIndex455
			return false
		},
		/* 87 EXISTS <- <('e' 'x' 'i' 's' 't' 's' _)> */
		func() bool {
			position457, tokenIndex457 := position, tokenIndex
			{
				position458 := position
				if buffer[position] != rune('e') {
					goto l457
				}
				position++
				if buffer[position] != rune('x') {
					goto l457
				}
				position++
				if buffer[position] != rune('i') {
					goto l457
				}
				position++
				if buffer[position] != rune('s') {
					goto l457
				}
				position++
				if buffer[position] != rune('t') {
					goto l457
				}
				position++
				if buffer[position] != rune('s') {
					goto l457
				}
				position++
				if !_rules[rule_]() {
					goto l457
				}
				add(ruleEXISTS, position458)
			}
			return true
		l457:
			position, tokenIndex = position457, tokenIndex457
			return false
		},
		/* 88 FREE <- <('f' 'r' 'e' 'e' _)> */
		func() bool {
			position459, tokenIndex459 := position, tokenIndex
			{
				position460 := position
				if buffer[position] != rune('f') {
					goto l459
				}
				position++
				if buffer[position] != rune('r') {
					goto l459
				}
				position++
				if buffer[position] != rune('e') {
					goto l459
				}
				position++
				if buffer[position] != rune('e') {
					goto l459
				}
				position++
				if !_rules[rule_]() {
					goto l459
				}
				add(ruleFREE, position460)
			}
			return true
		l459:
			position, tokenIndex = position459, tokenIndex459
			return false
		},
		/* 89 NEST <- <('n' 'e' 's' 't' _)> */
		func() bool {
			position461, tokenIndex461 := position, tokenIndex
			{
				position462 := position
				if buffer[position] != rune('n') {
					goto l461
				}
				position++
				if buffer[position] != rune('e') {
					goto l461
				}
				position++
				if buffer[position] != rune('s') {
					goto l461
				}
				position++
				if buffer[position] != rune('t') {
					goto l461
				}
				position++
				if !_rules[rule_]() {
					goto l461
				}
				add(ruleNEST, position462)
			}
			return true
		l461:
			position, tokenIndex = position461, tokenIndex461
			return false
		},
		/* 90 TRUE <- <('t' 'r' 'u' 'e' _)> */
		nil,
		/* 91 FALSE <- <('f' 'a' 'l' 's' 'e' _)> */
		nil,
		/* 92 EXTERNAL <- <('e' 'x' 't' 'e' 'r' 'n' 'a' 'l')> */
		func() bool {
			position465, tokenIndex465 := position, tokenIndex
			{
				position466 := position
				if buffer[position] != rune('e') {
					goto l465
				}
				position++
				if buffer[position] != rune('x') {
					goto l465
				}
				position++
				if buffer[position] != rune('t') {
					goto l465
				}
				position++
				if buffer[position] != rune('e') {
					goto l465
				}
				position++
				if buffer[position] != rune('r') {
					goto l465
				}
				position++
				if buffer[position] != rune('n') {
					goto l465
				}
				position++
				if buffer[position] != rune('a') {
					goto l465
				}
				position++
				if buffer[position] != rune('l') {
					goto l465
				}
				position++
				add(ruleEXTERNAL, position466)
			}
			return true
		l465:
			position, tokenIndex = position465, tokenIndex465
			return false
		},
		/* 93 NAME <- <('n' 'a' 'm' 'e')> */
		func() bool {
			position467, tokenIndex467 := position, tokenIndex
			{
				position468 := position
				if buffer[position] != rune('n') {
					goto l467
				}
				position++
				if buffer[position] != rune('a') {
					goto l467
				}
				position++
				if buffer[position] != rune('m') {
					goto l467
				}
				position++
				if buffer[position] != rune('e') {
					goto l467
				}
				position++
				add(ruleNAME, position468)
			}
			return true
		l467:
			position, tokenIndex = position467, tokenIndex467
			return false
		},
		/* 94 TYPE <- <('t' 'y' 'p' 'e')> */
		func() bool {
			position469, tokenIndex469 := position, tokenIndex
			{
				position470 := position
				if buffer[position] != rune('t') {
					goto l469
				}
				position++
				if buffer[position] != rune('y') {
					goto l469
				}
				position++
				if buffer[position] != rune('p') {
					goto l469
				}
				position++
				if buffer[position] != rune('e') {
					goto l469
				}
				position++
				add(ruleTYPE, position470)
			}
			return true
		l469:
			position, tokenIndex = position469, tokenIndex469
			return false
		},
		/* 95 VERB <- <('v' 'e' 'r' 'b')> */
		func() bool {
			position471, tokenIndex471 := position, tokenIndex
			{
				position472 := position
				if buffer[position] != rune('v') {
					goto l471
				}
				position++
				if buffer[position] != rune('e') {
					goto l471
				}
				position++
				if buffer[position] != rune('r') {
					goto l471
				}
				position++
				if buffer[position] != rune('b') {
					goto l471
				}
				position++
				add(ruleVERB, position472)
			}
			return true
		l471:
			position, tokenIndex = position471, tokenIndex471
			return false
		},
		/* 96 MECHANISM <- <('m' 'e' 'c' 'h' 'a' 'n' 'i' 's' 'm')> */
		func() bool {
			position473, tokenIndex473 := position, tokenIndex
			{
				position474 := position
				if buffer[position] != rune('m') {
					goto l473
				}
				position++
				if buffer[position] != rune('e') {
					goto l473
				}
				position++
				if buffer[position] != rune('c') {
					goto l473
				}
				position++
				if buffer[position] != rune('h') {
					goto l473
				}
				position++
				if buffer[position] != rune('a') {
					goto l473
				}
				position++
				if buffer[position] != rune('n') {
					goto l473
				}
				position++
				if buffer[position] != rune('i') {
					goto l473
				}
				position++
				if buffer[position] != rune('s') {
					goto l473
				}
				position++
				if buffer[position] != rune('m') {
					goto l473
				}
				position++
				add(ruleMECHANISM, position474)
			}
			return true
		l473:
			position, tokenIndex = position473, tokenIndex473
			return false
		},
		/* 97 ASYNC <- <('a' 's' 'y' 'n' 'c')> */
		func() bool {
			position475, tokenIndex475 := position, tokenIndex
			{
				position476 := position
				if buffer[position] != rune('a') {
					goto l475
				}
				position++
				if buffer[position] != rune('s') {
					goto l475
				}
				position++
				if buffer[position] != rune('y') {
					goto l475
				}
				position++
				if buffer[position] != rune('n') {
					goto l475
				}
				position++
				if buffer[position] != rune('c') {
					goto l475
				}
				position++
				add(ruleASYNC, position476)
			}
			return true
		l475:
			position, tokenIndex = position475, tokenIndex475
			return false
		},
		/* 98 EXPANDED <- <('e' 'x' 'p' 'a' 'n' 'd' 'e' 'd')> */
		func() bool {
			position477, tokenIndex477 := position, tokenIndex
			{
				position478 := position
				if buffer[position] != rune('e') {
					goto l477
				}
				position++
				if buffer[position] != rune('x') {
					goto l477
				}
				position++
				if buffer[position] != rune('p') {
					goto l477
				}
				position++
				if buffer[position] != rune('a') {
					goto l477
				}
				position++
				if buffer[position] != rune('n') {
					goto l477
				}
				position++
				if buffer[position] != rune('d') {
					goto l477
				}
				position++
				if buffer[position] != rune('e') {
					goto l477
				}
				position++
				if buffer[position] != rune('d') {
					goto l477
				}
				position++
				add(ruleEXPANDED, position478)
			}
			return true
		l477:
			position, tokenIndex = position477, tokenIndex477
			return false
		},
		/* 99 VERSION <- <('v' 'e' 'r' 's' 'i' 'o' 'n')> */
		nil,
		/* 100 ID <- <('i' 'd')> */
		nil,
		/* 101 PERSON <- <('p' 'e' 'r' 's' 'o' 'n' _)> */
		nil,
		/* 102 DATABASE <- <('d' 'a' 't' 'a' 'b' 'a' 's' 'e' _)> */
		nil,
		/* 103 QUEUE <- <('q' 'u' 'e' 'u' 'e' _)> */
		nil,
		/* 104 BLOBSTORE <- <('b' 'l' 'o' 'b' 's' 't' 'o' 'r' 'e' _)> */
		nil,
		/* 105 BROWSER <- <('b' 'r' 'o' 'w' 's' 'e' 'r' _)> */
		nil,
		/* 106 MOBILE <- <('m' 'o' 'b' 'i' 'l' 'e' _)> */
		nil,
		/* 107 SERVER <- <('s' 'e' 'r' 'v' 'e' 'r' _)> */
		nil,
		/* 108 DEVICE <- <('d' 'e' 'v' 'i' 'c' 'e' _)> */
		nil,
		/* 109 CODE <- <('c' 'o' 'd' 'e' _)> */
		nil,
		/* 110 DELIMITER <- <('$' '$')> */
		func() bool {
			position490, tokenIndex490 := position, tokenIndex
			{
				position491 := position
				if buffer[position] != rune('$') {
					goto l490
				}
				position++
				if buffer[position] != rune('$') {
					goto l490
				}
				position++
				add(ruleDELIMITER, position491)
			}
			return true
		l490:
			position, tokenIndex = position490, tokenIndex490
			return false
		},
		/* 111 QUOTE <- <'"'> */
		func() bool {
			position492, tokenIndex492 := position, tokenIndex
			{
				position493 := position
				if buffer[position] != rune('"') {
					goto l492
				}
				position++
				add(ruleQUOTE, position493)
			}
			return true
		l492:
			position, tokenIndex = position492, tokenIndex492
			return false
		},
		/* 112 EQUALS <- <'='> */
		func() bool {
			position494, tokenIndex494 := position, tokenIndex
			{
				position495 := position
				if buffer[position] != rune('=') {
					goto l494
				}
				position++
				add(ruleEQUALS, position495)
			}
			return true
		l494:
			position, tokenIndex = position494, tokenIndex494
			return false
		},
		/* 113 FLAG <- <('-' '-'?)> */
		func() bool {
			position496, tokenIndex496 := position, tokenIndex
			{
				position497 := position
				if buffer[position] != rune('-') {
					goto l496
				}
				position++
				{
					position498, tokenIndex498 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l498
					}
					position++
					goto l499
				l498:
					position, tokenIndex = position498, tokenIndex498
				}
			l499:
				add(ruleFLAG, position497)
			}
			return true
		l496:
			position, tokenIndex = position496, tokenIndex496
			return false
		},
		/* 114 STRICT <- <('s' 't' 'r' 'i' 'c' 't' _)> */
		nil,
		/* 115 VERBOSE <- <('v' 'e' 'r' 'b' 'o' 's' 'e' _)> */
		nil,
		/* 116 IDS <- <('i' 'd' 's' _)> */
		nil,
		/* 117 _ <- <Whitespace*> */
		func() bool {
			{
				position504 := position
			l505:
				{
					position506, tokenIndex506 := position, tokenIndex
					{
						position507 := position
						{
							switch buffer[position] {
							case '\t':
								if buffer[position] != rune('\t') {
									goto l506
								}
								position++
							case ' ':
								if buffer[position] != rune(' ') {
									goto l506
								}
								position++
							default:
								{
									position509 := position
									{
										position510, tokenIndex510 := position, tokenIndex
										if buffer[position] != rune('\r') {
											goto l511
										}
										position++
										if buffer[position] != rune('\n') {
											goto l511
										}
										position++
										goto l510
									l511:
										position, tokenIndex = position510, tokenIndex510
										if buffer[position] != rune('\n') {
											goto l512
										}
										position++
										goto l510
									l512:
										position, tokenIndex = position510, tokenIndex510
										if buffer[position] != rune('\r') {
											goto l506
										}
										position++
									}
								l510:
									add(ruleEOL, position509)
								}
							}
						}

						add(ruleWhitespace, position507)
					}
					goto l505
				l506:
					position, tokenIndex = position506, tokenIndex506
				}
				add(rule_, position504)
			}
			return true
		},
		/* 118 Whitespace <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EOL))> */
		nil,
		/* 119 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		nil,
		/* 120 END <- <!.> */
		func() bool {
			position515, tokenIndex515 := position, tokenIndex
			{
				position516 := position
				{
					position517, tokenIndex517 := position, tokenIndex
					if !matchDot() {
						goto l517
					}
					goto l515
				l517:
					position, tokenIndex = position517, tokenIndex517
				}
				add(ruleEND, position516)
			}
			return true
		l515:
			position, tokenIndex = position515, tokenIndex515
			return false
		},
		/* 122 Action0 <- <{
		   p.StmtType = "Response"
		 }> */
		nil,
		/* 123 Action1 <- <{
		   p.StmtType = "Command"
		   p.InputAttributes.Raw = p.Buffer
		 }> */
		nil,
		nil,
		/* 125 Action2 <- <{ p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text)) }> */
		nil,
		/* 126 Action3 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 127 Action4 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 128 Action5 <- <{ p.InputAttributes.Verb = "create-or-fetch" }> */
		nil,
		/* 129 Action6 <- <{ p.InputAttributes.Verb = "create-or-set" }> */
		nil,
		/* 130 Action7 <- <{
		   p.Response.Object.Type = "world"
		   p.Response.Object.Repr = strings.Join(append([]string{p.WorldParams["paramString"], p.TreeString}, p.RelStrings...), "\n")
		 }> */
		nil,
		/* 131 Action8 <- <{
		   p.Response.Object.Type = "item"; p.Response.Object.Repr = cleanString(text); p.ItemStrings = append(p.ItemStrings, strings.TrimSpace(text))
		   p.currentId = p.InputAttributes.ResourceId
		   p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})
		 }> */
		nil,
		/* 132 Action9 <- <{ p.Response.Object.Type = "rel"; p.Response.Object.Repr = cleanString(text); p.RelStrings = append(p.RelStrings, strings.TrimSpace(text)) }> */
		nil,
		/* 133 Action10 <- <{ p.Response.Object.Type = "ids"; b, _ := json.Marshal(p.InputAttributes.ResourceIds); p.Response.Object.Repr = string(b) }> */
		nil,
		/* 134 Action11 <- <{
		   p.StmtType = "Tree"; p.Response.Object.Type = "tree"; p.Response.Object.Repr = text; p.TreeString = text
		   if len(p.nodeStack) > 0 {
		     node := p.nodeStack[len(p.nodeStack)-1]
		     p.nodeStack = p.nodeStack[:len(p.nodeStack)-1]
		     if len(p.nodeStack) > 0 {
		       p.nodeStack[len(p.nodeStack)-1].Children = append(p.nodeStack[len(p.nodeStack)-1].Children, node)
		     } else {
		       p.Tree = node
		     }
		   }
		 }> */
		nil,
		/* 135 Action12 <- <{
		   p.currentId = "nil"
		   p.nodeStack = append(p.nodeStack, Node{Id: p.currentId, Children: []Node{}})
		 }> */
		nil,
		/* 136 Action13 <- <{
		   p.Response.Status.Message = cleanString(text)
		 }> */
		nil,
		/* 137 Action14 <- <{ p.Response.Status.Code = p.number }> */
		nil,
		/* 138 Action15 <- <{ p.InputAttributes.Params["limit"] = cleanString(text) }> */
		nil,
		/* 139 Action16 <- <{ p.InputAttributes.ResourceId = cleanString(text) }> */
		nil,
		/* 140 Action17 <- <{
		   p.InputAttributes.SecondaryIds = append(p.InputAttributes.SecondaryIds, cleanString(text))
		 }> */
		nil,
		/* 141 Action18 <- <{
		   p.InputAttributes.ResourceId = ""
		   ids := strings.Fields(text)
		   for _, id := range ids {
		     p.InputAttributes.ResourceIds = append(p.InputAttributes.ResourceIds, cleanString(id))
		   }
		 }> */
		nil,
		/* 142 Action19 <- <{
		   p.WorldParams["paramString"] = fmt.Sprintf("version=%s\nid=%s\nname=%s\nexpanded=%s", p.WorldParams["version"], p.WorldParams["id"], p.WorldParams["name"], p.WorldParams["expanded"])
		 }> */
		nil,
		/* 143 Action20 <- <{ p.WorldParams["version"] = cleanString(text) }> */
		nil,
		/* 144 Action21 <- <{ p.WorldParams["id"] = strings.TrimSpace(text) }> */
		nil,
		/* 145 Action22 <- <{ p.WorldParams["name"] = strings.TrimSpace(text) }> */
		nil,
		/* 146 Action23 <- <{ p.WorldParams["expanded"] = strings.TrimSpace(text) }> */
		nil,
		/* 147 Action24 <- <{ p.Params["external"] = cleanString(text) }> */
		nil,
		/* 148 Action25 <- <{ p.Params["type"] = cleanString(text) }> */
		nil,
		/* 149 Action26 <- <{ p.Params["name"] = cleanString(text) }> */
		nil,
		/* 150 Action27 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 151 Action28 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 152 Action29 <- <{ p.Params["verb"] = cleanString(text) }> */
		nil,
		/* 153 Action30 <- <{ p.Params["mechanism"] = cleanString(text) }> */
		nil,
		/* 154 Action31 <- <{ p.Params["async"] = cleanString(text) }> */
		nil,
		/* 155 Action32 <- <{ p.Params["expanded"] = cleanString(text) }> */
		nil,
		/* 156 Action33 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 157 Action34 <- <{ p.InputAttributes.Params[cleanString(text)] = "" }> */
		nil,
		/* 158 Action35 <- <{ p.text = cleanString(text) }> */
		nil,
		/* 159 Action36 <- <{ n, _ := strconv.Atoi(text); p.number = n }> */
		nil,
		/* 160 Action37 <- <{ p.bool = text == "true" }> */
		nil,
		/* 161 Action38 <- <{ p.InputAttributes.ResourceType = "item"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 162 Action39 <- <{ p.InputAttributes.ResourceType = "rel"; p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 163 Action40 <- <{ p.InputAttributes.ResourceType = "world" }> */
		nil,
		/* 164 Action41 <- <{ p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 165 Action42 <- <{ p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 166 Action43 <- <{ p.InputAttributes.Verb = "create" }> */
		nil,
		/* 167 Action44 <- <{ p.InputAttributes.Verb = "fetch" }> */
		nil,
		/* 168 Action45 <- <{ p.InputAttributes.Verb = "set" }> */
		nil,
		/* 169 Action46 <- <{ p.InputAttributes.Verb = "clear" }> */
		nil,
		/* 170 Action47 <- <{ p.InputAttributes.Verb = "delete" }> */
		nil,
		/* 171 Action48 <- <{ p.InputAttributes.Verb = "list" }> */
		nil,
		/* 172 Action49 <- <{ p.InputAttributes.Verb = "nest"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 173 Action50 <- <{ p.InputAttributes.Verb = "free"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 174 Action51 <- <{ p.InputAttributes.Verb = "exists" }> */
		nil,
		/* 175 Action52 <- <{ p.InputAttributes.Verb = "in?"; p.InputAttributes.ResourceType = "item" }> */
		nil,
		/* 176 Action53 <- <{ p.InputAttributes.Verb = "from?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 177 Action54 <- <{ p.InputAttributes.Verb = "to?"; p.InputAttributes.ResourceType = "rel" }> */
		nil,
		/* 178 Action55 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "strict") }> */
		nil,
		/* 179 Action56 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "verbose") }> */
		nil,
		/* 180 Action57 <- <{ p.InputAttributes.Flags = append(p.InputAttributes.Flags, "ids") }> */
		nil,
	}
	p.rules = _rules
	return nil
}
